/*

THIS CODE IN THIS FILE IS SORTA AUTOGENERATEDM ANYTHING BELOW LINE NUMBER

800 WAS AUTOGENERATED CODE, THIS SOURCE CODE MUST REMAIN UNTOUCHED UNLESS TOUCHED

BY A DEVELOPER OF THE RED RABBIT PROJECT, THIS CODE IS NOT ALL STABLE, NOR IS IT

THE BEST CODE TO BE RUNNING, IN FUTURE DEVELOPMENT THIS WILL BE CHANGED FOR NOW

PLEASE STEP AS FAR AWAY FROM THIS FILE AS POSSIBLE

*/
package switch_case

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"log"
	GENERAL_API_UTILS "main/API/requests"
	GENERAL_API_UTILS_SECTOR_28 "main/API/section-28"
	color "main/modg/colors"
	v "main/modg/colors"
	"main/modg/constants"
	opc "main/modg/copt"
	caller "main/modg/exec"
	execute "main/modg/exec"
	"main/modg/files"
	helpers "main/modg/helpers"
	helpers_CHAN "main/modg/helpers/chanchan"
	id_generation "main/modg/helpers/id-gen"
	jsa "main/modg/json"
	"main/modg/requests"
	Make_req "main/modg/requests"
	IEEE_Sniff "main/modg/scripts/IEEE-802.11/Network-Capture"
	IEEEParse "main/modg/scripts/IEEE-802.11/pcap_parsing"
	IEEE_Utils "main/modg/scripts/IEEE-802.11/recon"
	IEEE "main/modg/scripts/IEEE-802.11/system-con"
	system_interface_utils "main/modg/scripts/IEEE-802.11/system-con/interface-recon"
	brutes "main/modg/scripts/brute-forcing"
	azure "main/modg/scripts/cloud/azure"
	cloudfront_utils "main/modg/scripts/cloud/cloudfront/cloudfront-json"
	mcafe_utils "main/modg/scripts/cloud/mcafe/mcafe-json"
	cloud_pentesting "main/modg/scripts/cloud/payload-testing"
	dns "main/modg/scripts/domain/blocker"
	subdomain "main/modg/scripts/domain/subdom"
	forensics "main/modg/scripts/file-forensics"
	fuzz "main/modg/scripts/fuzzing"
	cr "main/modg/scripts/hashing/hashatk"
	generator "main/modg/scripts/hashing/hashgen"
	watchers "main/modg/scripts/httpr"
	"main/modg/scripts/lookup"
	stalk "main/modg/scripts/lookup"
	osintutils "main/modg/scripts/osint"
	malt_utils "main/modg/scripts/osint/maltego"
	phone_utils "main/modg/scripts/osint/phone"
	stego "main/modg/scripts/steg-osint"
	vuln "main/modg/scripts/vulnscans"
	win "main/modg/scripts/windows/pe"
	ssh_utils "main/modg/service/ssh"
	yml_utils "main/modg/service/ssh/ssh-yml-config"
	str "main/modg/sub"
	cv "main/modg/switch/casev"
	emod "main/modg/switch/errc"
	server "main/modg/switch/loggers"
	ios "main/modg/switch/scanners"
	"main/modg/warnings"
	ec "main/modg/warnings"
	runner_802 "main/modg2/80211/80211_runner"
	"main/modg2/MSF"
	Brute_Utils "main/modg2/brute"
	Mangle_DNS "main/modg2/dns_spoofer"
	"main/modg2/encryption/AES"
	Engine_CVE "main/modg2/engines/cve_engine/modules"
	Engine_OSINT "main/modg2/engines/osint_engine/modules"
	Engine_Shodan "main/modg2/engines/shodan_engine/modules"
	STOMPER "main/modg2/files"
	ENVIRON "main/modg2/scanners"
	services "main/modg2/services-etc"
	interface_cpp_utils "main/modules/go-main/80211/interfaces"
	SUPER_VARS "main/modules/go-main/SUPER-CONSTS"
	api_utils "main/modules/go-main/SUPER-MODS/config-reader"
	port_config "main/modules/go-main/SUPER-MODS/config-reader/port-config"
	burp_PARSER "main/modules/go-main/SUPER-MODS/data-parsers"
	system_utils_ghosted_Shell "main/modules/go-main/SUPER-MODS/etcutils/ghosted"
	pscan "main/modules/go-main/SUPER-MODS/host-discovery/simple-scanner"
	simple_super "main/modules/go-main/SUPER-MODS/image-generation/jpeg"
	QR_UTILS "main/modules/go-main/SUPER-MODS/image-generation/qr"
	XSSA "main/modules/go-main/SUPER-MODS/knoxss"
	regex "main/modules/go-main/SUPER-MODS/regex"
	SUPER_SSH "main/modules/go-main/SUPER-MODS/sessions"
	SUPER_Shodan_UTILS "main/modules/go-main/SUPER-MODS/shodan"
	file_utils "main/modules/go-main/SUPER-MODS/target-generation"
	UNZIP_SUPER_UTILS "main/modules/go-main/archive/dearchive-mod"
	gzip_decoder "main/modules/go-main/archive/decompress-mod"
	MAGIC_TESTER "main/modules/go-main/remoded/geo-jpg"
	GIT_Utils "main/modules/go-main/remoded/git"
	web3point0utils "main/modules/go-main/remoded/infector"
	xml_utils "main/modules/go-main/xml"
	SQL "main/modules/services/sql"
	"net"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"sync"
	"time"

	"main/modg/system-runscript"
)

type Data struct {
	Interfaces string
}

var server_binary string

func Banner(file, color string) {
	content, err := ioutil.ReadFile(file)
	ec.Ce(err, v.RED, "Could not read file", 1)
	fmt.Println(constants.Clear_hex, color, string(content))
}

func Help(file, color string) {
	content, err := ioutil.ReadFile(file)
	ec.Ce(err, v.RED, "Could not read file", 1)
	fmt.Println(color, string(content))
}

func File_check(filename string) bool {
	e, x := os.Stat(filename)
	if os.IsNotExist(x) {
		return false
	}
	return !e.IsDir()
}

func File_Write(filename, data string) {
	if !File_check(filename) {
		fmt.Println("<RR6> File check -> stat: File may not exist, creating a new file")
		_, x := os.Create(filename)
		if x != nil {
			fmt.Println("<RR6> File creation -> Could not create file got erorr -> ", x)
		}
		f, x := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if x != nil {
			fmt.Println("<RR6> File > I/O -> Reader > Writer: Got error when trying to open the filename, maybe this file does not exist")
		} else {
			defer f.Close()
			fmt.Fprintln(f, data)
		}
	}
}

func SSB(Screen_rotation string) {
	if Screen_rotation == "landscape" || Screen_rotation == "Landscape" {
		newfilepath, err := constants.Parse_filepath(constants.Team_logo_rr)
		ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, err, 1, 233, "")
		Banner(newfilepath, v.RED)
	}
	if Screen_rotation == "verticle" {
		newfilepath, err := constants.Parse_filepath(constants.Verticle_banner)
		ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, err, 1, 233, "")
		Banner(newfilepath, v.RED)
	}
	if Screen_rotation == "" {
		newfilepath, err := constants.Parse_filepath(constants.Verticle_banner)
		ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, err, 1, 233, "")
		Banner(newfilepath, v.RED)
	} else if Screen_rotation == "shark" {
		newfilepath, err := constants.Parse_filepath(constants.Shark)
		ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, err, 1, 233, "")
		Banner(newfilepath, v.RED)
	} else if Screen_rotation == "none" {
		fmt.Println(constants.Clear_hex)
	}
}

// simple io
func sio(msg, color string) string {
	var s string
	fmt.Print(color, msg)
	fmt.Scanf("%s", &s)
	return s
}

// simple INTIO
func iio32(msg, color string) float64 {
	var s float64
	fmt.Print(color, msg)
	fmt.Scanf("%v", &s)
	return s
}

// simple int io
func iio(msg, color string) int {
	var s int
	fmt.Print(color, msg)
	fmt.Scanf("%s", &s)
	return s
}

// simple int IO (TEST)
func IIO(msg, color string) int {
	var f int
	fmt.Print(color, msg)
	fmt.Scanf("%s", &f)
	return f
}

func DATE(msg, color string) time.Duration {
	var datatype time.Duration
	fmt.Print(color, msg)
	fmt.Scanf("%s", &datatype)
	return datatype
}

// advanced IO string
func AIO_S(msg, color string) string {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print(color, msg)
	value, _ := reader.ReadString('\n')
	return value
}

func Parse_options_for_netcap(layer_to_capture string, flag bool, sniff string) {
	if flag {
		var filteryn string
		a := sio("Enter an interface to use >>>> ", v.GRN)
		fmt.Print("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Init Setting: {Interface} -> ", a, "\n")
		fmt.Print("[-] Would you like to use a BPF (Berkly Packet Filter) (y/n)>>>> ")
		fmt.Scanf("%s", &filteryn)
		if filteryn == "y" {
			reader := bufio.NewReader(os.Stdin)
			fmt.Print("Enter a filter ex (tcp and port 80):>>>> ")
			filt, _ := reader.ReadString('\n')
			IEEE_Sniff.Live_Run(a, 1024, false, true, filt, 30*time.Second, layer_to_capture)
		} else {
			IEEE_Sniff.Live_Run(a, 1024, false, false, "tcp and port 80", 30*time.Second, layer_to_capture)
		}
	} else {
		var filteryn string
		fmt.Print("[-] Would you like to use a BPF (Berkly Packet Filter) (y/n)>>>> ")
		fmt.Scanf("%s", &filteryn)
		if filteryn == "yes" {
			filt := sio("Enter a filter ex(tcp and port 80) >>> ", v.RED)
			IEEE_Sniff.Live_Run(sniff, 1024, false, true, filt, 30*time.Second, layer_to_capture)
		} else {
			IEEE_Sniff.Live_Run(sniff, 1024, false, false, "tcp and port 80", 30*time.Second, layer_to_capture)
		}
	}
}

func Get_Proxy(url string, flags_rr6 *opc.RR6_options) {
	Status, _, Body, X := requests.Request_body(url, "GET")
	if X != nil {
		fmt.Println("<RR6> Got error when fetching proxy list -> ", X)
	} else {
		if Status == "200 OK" {
			if flags_rr6.Output == "" {
				file := sio("Enter an output filename -> ", v.HIGH_BLUE)
				File_Write(file, Body)
				fmt.Println("|+| Data written to -> ", file)

			} else {
				File_Write(flags_rr6.Output, Body)
				fmt.Println("|+| Data written to -> ", flags_rr6.Output)
			}
		}
	}
}

// case test function parser
/*

This is for testing only, in version 6.2 i plain to optimize this to types and json files and

databases which will be checked for commands pointed to its function like the following map

map[string]string{
	"command1": "function1"
}

map will be used to parse commands with their functions, if command1 is found function1 will be ran



*/
func M_TTY(command string, flags_rr6 *opc.RR6_options) {
	/*
		if command != "" {
			if IO_Settings.Open("config/io/IO-Settings.yaml") {
				SSB(flags_rr6.Screen_rotation)
			}
		}
	*/
	switch command {
	case "help start":
		f, x := os.Open("text/modules/start.txt")
		if x != nil {
			fmt.Println("<RR6> File module -> I/O: Could not read, find, or open file got error -> ", x)
		} else {
			defer f.Close()
			scanner := bufio.NewScanner(f)
			for scanner.Scan() {
				fmt.Println(v.HIGH_BLUE, scanner.Text())
			}
		}
	case "total commands":
		fmt.Println("208 commands YAY!")
	case "settings":
		fmt.Println(flags_rr6)
	case "commands":
		SSB(flags_rr6.Screen_rotation)
		if flags_rr6.Screen_rotation == "verticle" {
			nfp, e := constants.Parse_filepath("/text/menus/verticle_menu.txt")
			ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, e, 1, 233, "")
			Help(nfp, "\033[38m")
		} else {
			nfp, e := constants.Parse_filepath("/text/menus/landscape_menu.txt")
			ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, e, 1, 233, "")
			Help(nfp, "\033[38m")
		}
	case "h":
		SSB(flags_rr6.Screen_rotation)
		if flags_rr6.Screen_rotation == "verticle" {
			nfp, e := constants.Parse_filepath("/text/menus/verticle_menu.txt")
			ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, e, 1, 233, "")
			Help(nfp, "\033[38m")
		} else {
			nfp, e := constants.Parse_filepath("/text/menus/landscape_menu.txt")
			ec.Warning_advanced("<RR6> File Module: Could not open file for parsing -> ", v.REDHB, 1, false, false, true, e, 1, 233, "")
			Help(nfp, "\033[38m")
		}
	case "clear":
		SSB(flags_rr6.Screen_rotation)
	case "cls":
		SSB(flags_rr6.Screen_rotation)
	case "exit":
		fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| :D")
		os.Exit(0)
	case "help flags":
		fp := constants.Flags
		newfp := jsa.Read_filepath(fp)
		fmt.Println(newfp)
		jsa.Help_usage_and_menus(true, newfp, v.RED, "\n", 3)
	case "help commands":
		fp := constants.Sets
		newfp := jsa.Read_filepath(fp)
		jsa.Open(newfp)
	case "help verified":
		fp := constants.Verified_commands
		newfp := jsa.Read_filepath(fp)
		jsa.Open_json_verified_commands(newfp)
	case "help advanced":
		helpers.Usage("text/help/advance.txt", v.RED)
	case "help all":
		helpers.Readall()
	case "load examples":
		files.Getfp()
	case "time":
		system.Time()
	// fetching
	case "fetch proxy4":
		Get_Proxy("https://www.proxy-list.download/api/v1/get?type=socks4", flags_rr6)
	case "fetch proxy5":
		Get_Proxy("https://www.proxy-list.download/api/v1/get?type=socks5", flags_rr6)
	case "fetch http":
		Get_Proxy("https://api.proxyscrape.com/?request=displayproxies&proxytype=http&timeout=7000&country=ALL&anonymity=elite&ssl=no", flags_rr6)
	case "fetch https":
		Get_Proxy("https://api.proxyscrape.com/?request=displayproxies&proxytype=https&timeout=7000&country=ALL&anonymity=elite&ssl=no", flags_rr6)
	case "fetch httpssl":
		Get_Proxy("https://api.proxyscrape.com/?request=displayproxies&proxytype=http&timeout=7000&country=ALL&anonymity=elite&ssl=yes", flags_rr6)
	case "fetch httpsssl":
		Get_Proxy("https://api.proxyscrape.com/?request=displayproxies&proxytype=https&timeout=7000&country=ALL&anonymity=elite&ssl=yes", flags_rr6)
	//*************************************************************************************
	//*          This break concludes the file and help menu cases and inputs             *
	//*                                                                                   *
	//*************************************************************************************
	case "stalk mac":
		s, err := ios.Scanv(1, "Enter a MAC> ", v.RET_RED, "e", cv.Scan_variable)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.Mac_trace(s)
	case "stalk oui":
		fmt.Println("- EX: macs.txt ")
		s, err := ios.Scanv(1, "Enter a MAC file> ", v.RET_RED, "e", cv.Filename)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.Oui_filename(s)
	case "stalk hosts":
		fmt.Println(" - EX: 10.0.0")
		s, err := ios.Scanv(1, "Enter 3 network octets> ", v.RET_RED, "e", cv.Subnet)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.Sub_main(s)
	case "stalk hosts2":
		fmt.Println(" - EX: 10.0.")
		s, x := ios.Scanv(1, "Enter a number like the one below> ", v.RET_RED, "e", cv.Subnet)
		emod.Return_error(x, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		var W sync.WaitGroup
		for i := 0; i < 256; i++ {
			for k := 0; k < 256; k++ {
				W.Add(1)
				go func(addr string) {
					defer W.Done()
					lookup, err := net.LookupAddr(addr)
					if err == nil {
						for _, location := range lookup {
							fmt.Printf("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| \t %s \t\033[38;5;43m \t %s\n", addr, location)
						}
					}
				}(s + strconv.Itoa(i) + "." + strconv.Itoa(k))
			}
		}
		W.Wait()
		//*************************************************************************************
		//*          This break concludes the stalk modules for MACS                          *
		//*                                                                                   *
		//*************************************************************************************
	case "search domxss":
		a := sio("Enter a Vulnerable URL> ", v.RET_RED)
		conf := []string{a}
		web3point0utils.Check_DOMXSS(conf)
	case "search scan":
		fmt.Println(v.BLU, "[---] EX(23.61.61) first three are only allowed, last octet is randomized / added at the end")
		a := sio("Enter a hostname IP ", v.WHT)
		helpers_CHAN.Worker_Lookup(a, SUPER_VARS.Os_STD_THREAD_COUNT, SUPER_VARS.Oschan)
	case "search subdomains":
		a := sio("Enter a wordlist> ", v.RET_RED)
		b := sio("Enter a domain> ", v.RET_RED)
		c := sio("Enter a DNS server> ", v.RET_RED)
		SSB(flags_rr6.Screen_rotation)
		fmt.Println("________DOMAIN NAME______________IP ADDRESS______________")
		subdomain.Run(a, b, c)
	case "search redirect":
		a := sio("Enter a URL> ", v.RET_RED)
		Make_req.Create_Look_GET(a, 301)
	case "search port":
		a := sio("Enter a port number> ", v.RET_RED)
		xml_utils.Find_and_Search("xml/service-names-port-numbers.xml", a)
	case "search port live":
		a := sio("Enter a host to scan> ", v.RET_RED)
		config := pscan.Scan_range{
			Start: 1,
			End:   65535,
		}
		pscan.Scan("xml/service-names-port-numbers.xml", a, config)
	case "search port llive":
		a := sio("Enter a wordlist of hosts to scan> ", v.RET_RED)
		k, x := os.Open(a)
		if x != nil {
			fmt.Println(color.REDHB, "<RR6> Fatal Error: Could not find or open the file got error \033[39m", x, "\033[49m", color.RET_RED)
		} else {
			defer k.Close()
			scanner := bufio.NewScanner(k)
			config := pscan.Scan_range{
				Start: 1,
				End:   65535,
			}
			for scanner.Scan() {
				fmt.Println("###############################################################################################")
				fmt.Println("######## HOST / PORT INFORMATION FOR HOSTNAME -> ", scanner.Text(), "                        #")
				pscan.Scan("xml/service-names-port-numbers.xml", scanner.Text(), config)
				fmt.Println("###############################################################################################")
			}
		}
	case "search port custom":
		fmt.Println(color.HIGH_PINK, "[!] WARNING: USER: IF YOU CUSTOMIZED THE FOLLOWING FILE (config/scanconf/settings.yaml) THEN JUST HIT ENTER....")
		a := sio("Enter a config file> ", color.RET_RED)
		if a == "" {
			fmt.Println(color.HIGH_BLUE, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Using standard config file -> (config/scanconf/settings.yaml)")
			host, ps, pe, x := port_config.Open_and_return("config/scanconf/settings.yaml")
			if x != nil {
				log.Fatal(x)
			} else {
				pss, _ := strconv.Atoi(ps)
				pee, _ := strconv.Atoi(pe)
				config := pscan.Scan_range{
					Start: pss,
					End:   pee,
				}
				pscan.Scan("xml/service-names-port-numbers.xml", host, config)

			}
		} else {
			fmt.Println(color.HIGH_PINK, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Using custom config file that was inputted.....")
			host, ps, pe, x := port_config.Open_and_return(a)
			if x != nil {
				log.Fatal(x)
			} else {
				pss, _ := strconv.Atoi(ps)
				pee, _ := strconv.Atoi(pe)
				config := pscan.Scan_range{
					Start: pss,
					End:   pee,
				}
				pscan.Scan("xml/service-names-port-numbers.xml", host, config)

			}
		}

	case "search port l":
		a := sio("Enter a file with ports> ", v.RET_RED)
		c, x := os.Open(a)
		if x != nil {
			log.Fatal(x)
		} else {
			scanner := bufio.NewScanner(c)
			for scanner.Scan() {
				xml_utils.Find_and_Search("xml/service-names-port-numbers.xml", scanner.Text())
			}
		}

	case "search waf":
		s, x := ios.Scanv(1, "Enter a Payload> ", v.RET_RED, "e", "")
		emod.Return_error(x, "<RR6> I/O : Could not scan line or input ", 1, 2, false)
		cloud_pentesting.Payload(s)
	case "search head":
		s, err := ios.Scanv(1, "Enter a URL> ", v.RET_RED, "e", cv.Url)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.LookHead(s)
	case "search ns":
		s, err := ios.Scanv(1, "Enter a domain> ", v.RET_RED, "e", cv.Domain)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.LookNS(s)
	case "search mx":
		s, err := ios.Scanv(1, "Enter a domain> ", v.RET_RED, "e", cv.Domain)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.LookMX(s)
	case "search endpoint":
		if flags_rr6.Filepath_general == "" {
			s, err := ios.Scanv(1, "Enter a filepath to a host file> ", v.RET_RED, "e", cv.Filename)
			emod.Return_error(err, "Could not scan line or input", 1, 2, false)
			input := stalk.Scan_target_file(s)
			results := stalk.RetrieveContents(str.Rdv(input))
			for _, elem := range results {
				fmt.Println(elem[1 : len(elem)-1])
			}
		} else {
			s, err := ios.Scanv(1, "Enter a filepath to a host file> ", v.RET_RED, "e", cv.Filename)
			emod.Return_error(err, "Could not scan line or input", 1, 2, false)
			input := stalk.Scan_target_file(s)
			results := stalk.RetrieveContents(str.Rdv(input))
			for _, elem := range results {
				fmt.Println(elem[1 : len(elem)-1])
			}
		}
	case "search env":
		a := sio("Enter a URL -> ", v.BLU)
		fmt.Println(v.WHT)
		ENVIRON.Check_Env(false, "", a)
	case "search envf":
		a := sio("Enter a host file -> ", v.BLU)
		fmt.Println(v.WHT)
		ENVIRON.Check_Env(true, a, "")
	case "search phpbb":
		a := sio("Enter a URL that has PHPBB \t |> ", v.RET_RED)
		config := "-o phpbb -r " + a
		b := caller.RunA("perl", "r6.pl", config)
		fmt.Println(b)
	case "search ip":
		s, err := ios.Scanv(1, "Enter a host> ", v.RET_RED, "e", cv.Ipa)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n")
		stalk.LookIP(s)
		system.Sep("\n")
	case "search txt":
		s, err := ios.Scanv(1, "Enter a domain > ", v.RET_RED, "e", cv.Domain)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.Looktxt(s)
	case "search hostname":
		s, err := ios.Scanv(1, "Enter a IPA or host > ", v.RET_RED, "e", cv.Ipa)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		stalk.LookHSIP(s)
	case "search cname":
		s, err := ios.Scanv(1, "Enter a domain> ", v.RET_RED, "e", cv.Domain)
		emod.Return_error(err, "Could not scan line or input", 1, 2, false)
		system.Sep("\n\033[31m")
		cname, e := stalk.LookCNAME(string(s))
		if e != nil {
			fmt.Println("<RR6> Lookup Module: Can not lookup CNAME's - ", e)
		}
		fmt.Println("CNAME -> ", cname)
	case "search srv":
		fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Value1 should be -> domain")
		fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Value2 should be -> xmpp-server or server type")
		s := sio("Enter a domain name> ", v.RET_RED)
		s1 := sio("Enter a server type> ", v.RET_RED)
		stalk.LookSRV(s1, s)
	case "search robots":
		if flags_rr6.Url == "" {
			url, e := ios.Scanv(1, "Enter a URL> ", v.RET_RED, "e", cv.Domain)
			emod.Return_error(e, "Could not scan line or input", 1, 2, false)
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Setting: Initilized variable - ", url, " As a url to scan")
			stalk.LookRobot(url, "/robots.txt")
		} else {
			stalk.LookRobot(flags_rr6.Url, "/robots.txt")
		}
	case "search urls":
		url, e := ios.Scanv(1, "Enter a URL> ", v.RET_RED, "e", cv.Url)
		emod.Return_error(e, "Could not scan line or input", 1, 2, false)
		domain, e := ios.Scanv(1, "Enter a domain> ", v.RET_RED, "e", cv.Domain)
		emod.Return_error(e, "Could not scan line or input", 1, 2, false)
		httpurl, e := ios.Scanv(1, "Enter a HTTP url> ", v.RET_RED, "e", cv.Httpurl)
		emod.Return_error(e, "Could not scan line or input", 1, 2, false)
		lookup.Search_urls(url, domain, httpurl)
	case "search banner":
		ip, e := ios.Scanv(1, "Enter a host/ip to dial> ", v.RET_RED, "e", cv.Ipa)
		emod.Return_error(e, "Could not scan line or input", 1, 2, false)
		stalk.Lookup_banner_main(ip)
	case "search ipa":
		if flags_rr6.Url == "" {
			url, e := ios.Scanv(1, "Enter a URL> ", v.RET_RED, "e", cv.Url)
			emod.Return_error(e, "Could not scan line or input", 1, 2, false)
			lookup.LookIP(url)
		} else {
			lookup.LookIP(flags_rr6.Url)
		}
	case "search server":
		if flags_rr6.Url == "" {
			url, e := ios.Scanv(1, "Enter a URL>", v.RET_RED, "e", cv.Url)
			emod.Return_error(e, "Could not scan line or input", 1, 2, false)
			a, e := requests.GET_val(url, "GET", "server")
			emod.Return_error(e, "Could make a proper response", 1, 2, false)
			fmt.Println("\n\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Server -> ", a)
		} else {
			a, e := requests.GET_val(flags_rr6.Url, "GET", "server")
			emod.Return_error(e, "Could make a proper response", 1, 2, false)
			fmt.Println("\n\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Server -> ", a)
		}
	case "search xss knoxss":
		a := sio("Enter your KNOXSS API Key -> ", v.RET_RED)
		b := sio("Enter your target URL     -> ", v.RET_RED)
		Response, _, x := XSSA.Make_Request(b, a)
		if x != nil {
			fmt.Println(v.REDHB, "<RR6> Search Module: Got error when trying to run the KNOXSS tester -> ")
			fmt.Println(x)
		} else {
			r, x := XSSA.READER(Response)
			if x != nil {
				fmt.Println(v.REDHB, "<RR6> Search Module: Got error when trying to read the response from func(x1) -> ", x)
			} else {
				if r.Cross_Site_Scripting == "true" {
					fmt.Println(v.HIGH_PINK, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Positive Results for url -> ", b, " | XSS Vulnerability found")
				}
				if r.Cross_Site_Scripting == "false" {
					fmt.Println(v.HIGH_BLUE, "[!] Negative results for url -> ", b, " | No XSS Vulns found")
				}
				if r.Cross_Site_Scripting == "none" || r.Knoxss_Error != "" {
					fmt.Println(v.REDHB, "<RR6> Recon Module: API: Got error when running XSS testers -> ", r.Knoxss_Error)
				}
			}
		}
	case "search xss knoxl":
		a := sio("Enter your knoxss api Key  -> ", v.RET_RED)
		b := sio("Enter the wordlist of urls -> ", v.RET_RED)
		f, x := os.Open(b)
		if x != nil {
			fmt.Println("<RR6> File I/O> Got error when trying to open, read, or locate file -> ", x)
		} else {
			scanner := bufio.NewScanner(f)
			for scanner.Scan() {
				Response, _, x := XSSA.Make_Request(scanner.Text(), a)
				if x != nil {
					fmt.Println(v.REDHB, "<RR6> Search Module: Got error when trying to run the KNOXSS tester -> ")
					fmt.Println(x)
				} else {
					r, x := XSSA.READER(Response)
					if x != nil {
						fmt.Println(v.REDHB, "<RR6> Search Module: Got error when trying to read the response from func(x1) -> ", x)
					} else {
						if r.Cross_Site_Scripting == "true" {
							fmt.Println(v.HIGH_PINK, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Positive Results for url -> ", b, " | XSS Vulnerability found")
						}
						if r.Cross_Site_Scripting == "false" {
							fmt.Println(v.HIGH_BLUE, "[!] Negative results for url -> ", b, " | No XSS Vulns found")
						}
						if r.Cross_Site_Scripting == "none" || r.Knoxss_Error != "" {
							fmt.Println(v.REDHB, "<RR6> Recon Module: API: Got error when running XSS testers -> ", r.Knoxss_Error)
						}
					}
				}
			}
		}
	case "search xsskno custom":
		api_key := api_utils.Return_KNOXSS("config/api_key.yaml")
		target := sio("Enter a target URL> ", v.RET_RED)
		Response, _, x := XSSA.Make_Request(target, api_key)
		if x != nil {
			fmt.Println(v.REDHB, "<RR6> Search Module: Got error when trying to run the KNOXSS tester -> ")
			fmt.Println(x)
		} else {
			r, x := XSSA.READER(Response)
			if x != nil {
				fmt.Println(v.REDHB, "<RR6> Search Module: Got error when trying to read the response from func(x1) -> ", x)
			} else {
				if r.Cross_Site_Scripting == "true" {
					fmt.Println(v.HIGH_PINK, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Positive Results for url -> ", target, " | XSS Vulnerability found")
				}
				if r.Cross_Site_Scripting == "false" {
					fmt.Println(v.HIGH_BLUE, "[!] Negative results for url -> ", target, " | No XSS Vulns found")
				}
				if r.Cross_Site_Scripting == "none" || r.Knoxss_Error != "" {
					fmt.Println(v.REDHB, "<RR6> Recon Module: API: Got error when running XSS testers -> ", r.Knoxss_Error)
				}
			}
		}
	case "search route":
		caller.Traceroute()
	case "search admin":
		fmt.Println(flags_rr6.Url)
		fmt.Println(flags_rr6.PayloadList)
		// if ios.scanv does not work, then use sio, this works better there must be something wrong with the way the valuesd are being read and sent back in ios
		if flags_rr6.Url == "" || flags_rr6.PayloadList == "" {
			a := sio("Enter a URL> ", v.RET_RED)
			b := sio("Enter path to admin panel payload list or a payload list>", v.RET_RED)
			vuln.AdminFinder(a, b)
		} else {
			vuln.AdminFinder(flags_rr6.Url, flags_rr6.PayloadList)
		}
	case "search sqli":
		if flags_rr6.Url == "" || flags_rr6.PayloadList == "" {
			a := sio("Enter a URL> ", v.RET_RED)
			b := sio("Enter path to admin panel payload list or a payload list>", v.RET_RED)
			vuln.SQLIfinderMAIN(a, b)
		} else {
			vuln.SQLIfinderMAIN(flags_rr6.Url, flags_rr6.PayloadList)
		}
	case "search lfi":
		if flags_rr6.Url == "" {
			a := sio("Enter a URL> ", v.RET_RED)
			system.Call_perl_lfiscan(a)
		} else {
			system.Call_perl_lfiscan(flags_rr6.Url)

		}
	case "search sig":
		if flags_rr6.Input == "" {
			a := sio("Enter a Filepath or filename to be scanned> ", v.RET_RED)
			stego.File_sig(a)
		} else {
			stego.File_sig(flags_rr6.Input)
		}
	case "search filepath":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a filepath to be searched> ", v.RET_RED)
			system.Walker_caller(a)
		} else {
			system.Walker_caller(flags_rr6.Filepath_general)
		}
	case "search archive":
		if flags_rr6.Input == "" {
			a := sio("Enter a JPG Image to be looked at> ", v.RET_RED)
			o := sio("Enter the designated extracted filepath> ", v.RET_RED)
			caller.Call_perl_s(a)
			forensics.Extract_ZIP(a, o)
		} else {
			caller.Call_perl_s(flags_rr6.Input)
			forensics.Extract_ZIP(flags_rr6.Input, flags_rr6.Output)
		}
	case "search geo":
		if flags_rr6.Input == "" {
			fmt.Println("WARN: FILE MUST BE JPG/JPEG")
			a := sio("Enter a JPG Image to be looked at> ", v.RET_RED)
			stego.Geo_loc(a)
		} else {
			stego.Geo_loc(flags_rr6.Input)
		}
	case "search methods *":
		var res []string
		var reslen []int
		a := sio("Enter a URL> ", v.RET_RED)
		gstat, lensSb, x := requests.Create_GET(a)
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new GET methodized request, got error -> ", v.REDHB)
		pstat, lensSSb, x := requests.Create_POST(a)
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new POST methodized request, got error -> ", v.REDHB)
		dstat, lensSSSb, x := requests.Request(a, "DELETE")
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new DELETE methodized request, got error -> ", v.REDHB)
		hstat, lensSSSSb, x := requests.Create_HEAD(a)
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new HEAD methodized request, got error -> ", v.REDHB)
		cstat, lensSSSSSb, x := requests.Request(a, "CONNECT")
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new CONNECT methodized request, got error -> ", v.REDHB)
		ostat, lensSSSSSSb, x := requests.Request(a, "OPTIONS")
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new OPTIONS methodized request, got error -> ", v.REDHB)
		tstat, lensSSSSSSSb, x := requests.Request(a, "TRACE")
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new TRACE methodized request, got error -> ", v.REDHB)
		patchstat, lensSSSSSSSb, x := requests.Request(a, "PATCH")
		requests.Check_error(x, "<RR6> Requests Module: Could not make a new PATCH methodized request, got error -> ", v.REDHB)
		res = append(res, gstat, pstat, dstat, hstat, cstat, ostat, tstat, patchstat)
		reslen = append(reslen, lensSb, lensSSb, lensSSSb, lensSSSSb, lensSSSSSb, lensSSSSSSb, lensSSSSSSSb)
		fmt.Println("<RR6> USER WARNING: For more information on methodized codes, use command `search httpmethod *`")
		fmt.Println("----METHOD----#----STATUS----#----BODY SIZE----#")
		counter := 0
		for _, i := range res {
			counter++
			for _, k := range reslen {
				fmt.Println(v.RET_RED, "> ", v.HIGH_BLUE, "\t", counter, v.HIGH_PINK, "\t", i, v.MAG, "\t", k)
			}
		}
	case "search httpmethod *":
		list := []string{
			"METHOD NUMBER | 1 | -> PUT",
			"METHOD NUMBER | 2 | -> GET",
			"METHOD NUMBER | 3 | -> CONNECT",
			"METHOD NUMBER | 4 | -> POST",
			"METHOD NUMBER | 5 | -> DELETE",
			"METHOD NUMBER | 6 | -> TRACE",
			"METHOD NUMBER | 7 | -> OPTIONS",
			"METHOD NUMBER | 8 | -> PATCH",
		}
		for _, i := range list {
			fmt.Println(v.WHT, i)
		}
		//*************************************************************************************
		//*          This break concludes the search modules for OSINT and web recon          *
		//*                                                                                   *
		//*************************************************************************************
	case "fetch links":
		if flags_rr6.Url == "" {
			a := sio("Enter a URL> \033[39m", v.BLKHB)
			r, e := watchers.Fetch_Links(a)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		} else {
			r, e := watchers.Fetch_Links(flags_rr6.Url)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		}
	case "fetch title":
		if flags_rr6.Url == "" {
			a := sio("Enter a URL> \033[39m", v.BLKHB)
			r, e := watchers.Fetch_Title(a)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		} else {
			r, e := watchers.Fetch_Title(flags_rr6.Url)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		}
	case "fetch lists":
		if flags_rr6.Url == "" {
			a := sio("Enter a URL> \033[39m", v.BLKHB)
			r, e := watchers.Fetch_LI(a)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		} else {
			r, e := watchers.Fetch_LI(flags_rr6.Url)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		}
	case "fetch documents":
		if flags_rr6.Url == "" {
			a := sio("Enter a URL> \033[39m", v.BLKHB)
			r, e := watchers.Fetch_doc(a)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		} else {
			r, e := watchers.Fetch_doc(flags_rr6.Url)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			fmt.Println(r)
		}
	case "fetch external":
		if flags_rr6.Url == "" {
			a := sio("Enter a URL> \033[39m", v.RET_RED)
			r, e := watchers.Fetch_ext(a)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			for _, k := range r {
				fmt.Println("\033[31m|\033[90m+\033[31m| Document -> ", k)
			}
		} else {
			r, e := watchers.Fetch_ext(flags_rr6.Url)
			warnings.Warning_simple("<RR6> UIO Module: Could not call watchers - ", v.REDHB, e)
			for _, k := range r {
				fmt.Println("\033[31m|\033[90m+\033[31m| Document -> ", k)
			}
		}

		//*************************************************************************************
		//*          This break concludes the Watchers for HTML recon / parsing               *
		//*                                                                                   *
		//*************************************************************************************
	case "inject payload":
		a := sio("Enter a URL> ", v.RET_RED)
		payload := sio("Enter a payload string> ", v.RET_RED)
		parser := requests.Remove_Params(a, payload)
		fmt.Println(parser)
	case "inject payloadl":
		a := sio("Enter a URL> ", v.RET_RED)
		b := sio("Enter a payload list> ", v.RET_RED)
		f, x := os.Open(b)
		if x != nil {
			fmt.Println("<RR6> File I/O In SWITCH: Could not open filename, find filename, or read filename, got error -> ", x)
		} else {
			scanner := bufio.NewScanner(f)
			for scanner.Scan() {
				parser := requests.Remove_Params(a, scanner.Text())
				fmt.Println(parser, "\n", "")
			}
		}
	case "inject payloadul":
		a := sio("Enter a list of URLS> ", v.RET_RED)
		b := sio("Enter a payload     > ", v.RET_RED)
		f, x := os.Open(a)
		if x != nil {
			fmt.Println("<RR6> File I/O In SWITCH: Could not open filename, find filename, or read filename, got error -> ", x)
		} else {
			scanner := bufio.NewScanner(f)
			for scanner.Scan() {
				parser := requests.Remove_Params(scanner.Text(), b)
				fmt.Println(parser)
			}
		}
	case "inject zip":
		if flags_rr6.Input == "" || flags_rr6.Filepath_general == "" || flags_rr6.Output == "" {
			a := sio("Enter a JPG Image to be injected> ", v.RET_RED)
			system.Sep("\n")
			b := sio("Enter a ZIP file to be injected into the image> ", v.RET_RED)
			system.Sep("\n")
			c := sio("Enter a output file> ", v.RET_RED)
			caller.Call_perl_s(a)
			forensics.Inject_ZIP(a, b, c)
		} else {
			caller.Call_perl_s(flags_rr6.Input)
			forensics.Inject_ZIP(flags_rr6.Input, flags_rr6.Filepath_general, flags_rr6.Output)
		}
	case "dump bootsec info":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a Boot sec filepath> ", v.RET_RED)
			forensics.Dump_boots(a)
		} else {
			forensics.Dump_boots(flags_rr6.Filepath_general)
		}
	case "dump file info":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a filepath or file to be dumped> ", v.RET_RED)
			system.File_inf(a)
		} else {
			system.File_inf(flags_rr6.Filepath_general)
		}
	case "dump file binary":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a file to be dumped into hex> ", v.RET_RED)
			stego.Hex_dump(a)
		} else {
			stego.Hex_dump(flags_rr6.Filepath_general)
		}
	case "dump pe info":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a PE file to be dumped> ", v.RET_RED)
			inf, e := win.Parser(a)
			if e != nil {
				fmt.Println("<RR6> Windows Module: Could not get information on PE file, parse file, or open file -> ", e)
			} else {
				fmt.Println(inf)
			}
		} else {
			inf, e := win.Parser(flags_rr6.Filepath_general)
			if e != nil {
				fmt.Println("<RR6> Windows Module: Could not get information on PE file, parse file, or open file -> ", e)
			} else {
				fmt.Println(inf)
			}
		}
	case "dump image metadata":
		if flags_rr6.Input == "" {
			a := sio("Enter a filepath to an image to dump> ", v.RET_RED)
			caller.Call_perl_s(a)
		} else {
			caller.Call_perl_s(flags_rr6.Input)
		}
	case "run RR6 GUI":
		caller.Call_perl_RR6_GUI()
	case "run RR6 scan gui":
		if flags_rr6.Iprange == "" {
			a := sio("Enter a CIDR> ", v.RET_RED)
			caller.Call_perl_GUI_host_scanner(a)
		} else {
			caller.Call_perl_GUI_host_scanner(flags_rr6.Iprange)
		}
		//*************************************************************************************
		//*          This break concludes the dumping and file information/sys calls          *
		//*                                                                                   *
		//*************************************************************************************
	case "inject bmp":
		if flags_rr6.Input == "" || flags_rr6.Payload == "" {
			a := sio("Enter a image to   inject> ", v.RET_RED)
			system.Sep("\n")
			b := sio("Enter a payload to inject> ", v.RET_RED)
			system.Sep("\n")
			caller.Run_bmp(b, a)
			caller.Call_perl_s(a)
		} else {
			caller.Run_bmp(flags_rr6.Payload, flags_rr6.Input)
			caller.Call_perl_s(flags_rr6.Input)
		}
	case "inject jpg":
		if flags_rr6.Input == "" || flags_rr6.Payload == "" || flags_rr6.Type == "" {
			a := sio("Enter a image to   inject> ", v.RET_RED)
			system.Sep("\n")
			b := sio("Enter a payload to inject> ", v.RET_RED)
			system.Sep("\n")
			fmt.Println("\033[32mChunks -> {'COM' or 'DQT'}")
			c := sio("\033[31mEnter a chunk to   inject> ", v.RET_RED)
			caller.Run_JPG(c, b, a)
			caller.Call_perl_s(a)
		} else {
			caller.Run_JPG(flags_rr6.Jpgchunk, flags_rr6.Payload, flags_rr6.Input)
			caller.Call_perl_s(flags_rr6.Input)
		}
	case "inject gif":
		if flags_rr6.Input == "" || flags_rr6.Payload == "" || flags_rr6.Pheight == "" || flags_rr6.Pwidth == "" {
			a := sio("Enter a image to   inject> ", v.RET_RED)
			system.Sep("\n")
			b := sio("Enter a payload to inject> ", v.RET_RED)
			system.Sep("\n")
			c := sio("Enter a pixel height> ", v.RET_RED)
			system.Sep("\n")
			d := sio("Enter a pixel width> ", v.RET_RED)
			caller.Run_GIF(a, b, c, d)
			caller.Call_perl_s(a)
		} else {
			caller.Run_GIF(flags_rr6.Input, flags_rr6.Payload, flags_rr6.Pheight, flags_rr6.Pwidth)
			caller.Call_perl_s(flags_rr6.Input)
		}
	case "inject webp":
		if flags_rr6.Input == "" || flags_rr6.Payload == "" || flags_rr6.Pheight == "" || flags_rr6.Pwidth == "" {
			a := sio("Enter a image to   inject> ", v.RET_RED)
			system.Sep("\n")
			b := sio("Enter a payload to inject> ", v.RET_RED)
			system.Sep("\n")
			caller.Run_Webp(a, b)
			caller.Call_perl_s(a)
		} else {
			caller.Run_Webp(flags_rr6.Input, flags_rr6.Payload)
			caller.Call_perl_s(flags_rr6.Input)
		}
	//*************************************************************************************
	//*          This break concludes the injection / stegonography section               *
	//*                                                                                   *
	//*************************************************************************************
	case "ping udp":
		if flags_rr6.Iprange == "" {
			a := sio("Enter a CIDR> ", v.RET_RED)
			execute.Host_discover_r6("discover_udp", a)
		} else {
			execute.Host_discover_r6("discover_udp", flags_rr6.Iprange)
		}
	case "ping tcp":
		if flags_rr6.Iprange == "" {
			a := sio("Enter a CIDR> ", v.RET_RED)
			execute.Host_discover_r6("discover_tcp", a)
		} else {
			execute.Host_discover_r6("discover_tcp", flags_rr6.Iprange)
		}
	case "ping syn":
		if flags_rr6.Iprange == "" {
			a := sio("Enter a CIDR> ", v.RET_RED)
			execute.Host_discover_r6("discover_syn", a)
		} else {
			execute.Host_discover_r6("discover_syn", flags_rr6.Iprange)
		}
	case "ping icmp":
		if flags_rr6.Iprange == "" {
			a := sio("Enter a CIDR> ", v.RET_RED)
			execute.Host_discover_r6("discover_icmp", a)
		} else {
			execute.Host_discover_r6("discover_icmp", flags_rr6.Iprange)
		}
	case "ping arp":
		IEEE_Utils.Return_Values_andCall()

	//*************************************************************************************
	//*          This break concludes the network recon / scanning sectuion               *
	//*                                                                                   *
	//*************************************************************************************
	case "crack sha1 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Brute_list == "" {
			a := sio("Enter a Hash list> ", v.RET_RED)
			b := sio("Enter a Wordlist > ", v.RET_RED)
			cr.Brute_SHA1_wordlist(b, a)
		} else {
			cr.Brute_SHA1_wordlist(flags_rr6.Brute_list, flags_rr6.Hashlist)
		}
	case "crack sha1 single":
		a := sio("Enter a SHA1 hash> ", v.RET_RED)
		b := sio("Enter a Wordlist > ", v.RET_RED)
		cr.Brute_SHA1_single(b, a)
	case "crack md5 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Brute_list == "" {
			a := sio("Enter a Hash list> ", v.RET_RED)
			b := sio("Enter a Wordlist > ", v.RET_RED)
			cr.Brute_MD5_wordlist(b, a)
		} else {
			cr.Brute_MD5_wordlist(flags_rr6.Brute_list, flags_rr6.Hashlist)
		}
	case "crack md5 single":
		a := sio("Enter a MD5 hash> ", v.RET_RED)
		b := sio("Enter a Wordlist > ", v.RET_RED)
		cr.Brute_MD5_Single(b, a)
	case "crack sha256 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Brute_list == "" {
			a := sio("Enter a Hash list> ", v.RET_RED)
			b := sio("Enter a Wordlist > ", v.RET_RED)
			cr.Brute_SHA256_main(a, b)
		} else {
			cr.Brute_SHA256_main(flags_rr6.Hashlist, flags_rr6.Brute_list)
		}
	case "crack mysql vb":
		if flags_rr6.Brute_list == "" || flags_rr6.Filepath_general == "" {
			a := sio("Enter a path to the wordlist> ", v.RET_RED)
			b := sio("Enter a path to the SQL File> ", v.RET_RED)
			helpers.Call_sql(a, b)
		} else {
			helpers.Call_sql(flags_rr6.Brute_list, flags_rr6.Filepath_general)
		}
	case "crack sha256 single":
		a := sio("Enter a SHA256 hash> ", v.RET_RED)
		b := sio("Enter a Wordlist > ", v.RET_RED)
		cr.Brute_SHA256_main_Single(b, a)
	case "encode md5":
		a := sio("Enter a string> ", v.RET_RED)
		generator.Call_all("md5", "", a)
	case "encode sha1":
		a := sio("Enter a string> ", v.RET_RED)
		generator.Call_all("sha1", "", a)
	case "encode sha256":
		a := sio("Enter a string> ", v.RET_RED)
		generator.Call_all("sha256", "", a)
	case "encode sha512":
		a := sio("Enter a string> ", v.RET_RED)
		generator.Call_all("sha512", "", a)
	case "encode base64":
		a := sio("Enter a string> ", v.RET_RED)
		generator.Call_all("base64", "", a)
	case "encode base32":
		a := sio("Enter a string> ", v.RET_RED)
		generator.Call_all("base32", "", a)
	case "encode rot13":
		a := sio("Enter a string> ", v.RET_RED)
		generator.Call_all("rot13", "", a)
	case "encode HMAC":
		a := sio("Enter a string> ", v.RET_RED)
		b := sio("Enter a key   > ", v.RET_RED)
		generator.Call_all("HMAC", a, b)
	//*************************************************************************************
	//*          This break is to seperate the make module for requests                   *
	//*                                                                                   *
	//*************************************************************************************
	case "make GET":
		a := sio("Enter a HTTP(s) URL> ", v.RET_RED)
		status, body_len, body, x := Make_req.Request_body(a, "GET")
		if x != nil {
			fmt.Println("<RR6> Requests module: Got error when making a request to the given URL -> ", x)
		} else {
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| STATUS CODE - \033[38;5;43m", status)
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Body Length - \033[38;5;43m", body_len)
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Response    - \033[38;5;43m", body)
		}
	case "make POST":
		a := sio("Enter a HTTP(s) URL> ", v.RET_RED)
		b := sio("Enter the json data to post> ", v.RET_RED)
		status, body_len, body, x := Make_req.Create_POST_data(a, b)
		if x != nil {
			fmt.Println("<RR6> Requests module: Got error when making a request to the given URL -> ", x)
		} else {
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| STATUS CODE - \033[38;5;43m", status)
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Body Length - \033[38;5;43m", body_len)
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Response    - \033[38;5;43m", body)
		}
	case "make PUT":
		a := sio("Enter a HTTP(s) URL> ", v.RET_RED)
		b := sio("Enter the json data to put> ", v.RET_RED)
		status, body_len, body, x := Make_req.Create_PUT_data(a, b)
		if x != nil {
			fmt.Println("<RR6> Requests module: Got error when making a request to the given URL -> ", x)
		} else {
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| STATUS CODE - \033[38;5;43m", status)
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Body Length - \033[38;5;43m", body_len)
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Response    - \033[38;5;43m", body)
		}

	// file type generation, file.txt all hashes or words in that file will be hashed
	case "encode md5 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Output == "" {
			a := sio("Enter a wordlist to hash> ", v.RET_RED)
			b := sio("Enter a output list to out data to> ", v.RET_RED)
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a MD5 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(a, b, 1)
		} else {
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a MD5 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(flags_rr6.Hashlist, flags_rr6.Output, 1)
		}
	case "encode sha1 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Output == "" {
			a := sio("Enter a wordlist to hash> ", v.RET_RED)
			b := sio("Enter a output list to out data to> ", v.RET_RED)
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a SHA1 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(a, b, 2)
		} else {
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a SHA1 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(flags_rr6.Hashlist, flags_rr6.Output, 2)
		}
	case "encode sha256 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Output == "" {
			a := sio("Enter a wordlist to hash> ", v.RET_RED)
			b := sio("Enter a output list to out data to> ", v.RET_RED)
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a SHA256 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(a, b, 3)
		} else {
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a SHA256 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(flags_rr6.Hashlist, flags_rr6.Output, 3)
		}
	case "encode sha512 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Output == "" {
			a := sio("Enter a wordlist to hash> ", v.RET_RED)
			b := sio("Enter a output list to out data to> ", v.RET_RED)
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a SHA512 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(a, b, 7)
		} else {
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a SHA512 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(flags_rr6.Hashlist, flags_rr6.Output, 7)

		}
	case "encode base32 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Output == "" {
			a := sio("Enter a wordlist to hash> ", v.RET_RED)
			b := sio("Enter a output list to out data to> ", v.RET_RED)
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a Base32 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(a, b, 4)
		} else {
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a Base32 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(flags_rr6.Hashlist, flags_rr6.Output, 4)
		}
	case "encode base64 list":
		if flags_rr6.Hashlist == "" || flags_rr6.Output == "" {
			a := sio("Enter a wordlist to hash> ", v.RET_RED)
			b := sio("Enter a output list to out data to> ", v.RET_RED)
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a Base64 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(a, b, 5)
		} else {
			fmt.Println("--------------------------------------------------------")
			fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Converting all words in the list to a Base64 hash ---")
			fmt.Print("\n")
			generator.Listed_Generation(flags_rr6.Hashlist, flags_rr6.Output, 5)

		}

	//*************************************************************************************
	//*          This break concludes the hashing, crypto, encoding modules and commands  *
	//*                                                                                   *
	//*************************************************************************************
	case "dump pcap dot11":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to 802.11 Pcap file> ", v.RET_RED)
			IEEEParse.Open_parse_BSSID(a)
		} else {
			IEEEParse.Open_parse_BSSID(flags_rr6.Filepath_general)
		}
	case "dump pcap ftp":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to FTP/net Pcap file> ", v.RET_RED)
			IEEEParse.Ftp_sniff_OFFLINE_PCAP(a, true)
		} else {
			IEEEParse.Ftp_sniff_OFFLINE_PCAP(flags_rr6.Filepath_general, true)
		}
	case "dump pcap ospf":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to OSPF/net Pcap file> ", v.RET_RED)
			IEEEParse.OSPF_OFFLINE_Parsing(a)
		} else {
			IEEEParse.OSPF_OFFLINE_Parsing(flags_rr6.Filepath_general)
		}
	case "dump pcap smtppa":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to SMTP/net Pcap file> ", v.RET_RED)
			IEEEParse.Pcap_parser_OFFLINE(a, "AUTH PLAIN")
		} else {
			IEEEParse.Pcap_parser_OFFLINE(flags_rr6.Filepath_general, "AUTH PLAIN")
		}
	case "dump pcap smtpe":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to SMTP/net Pcap file> ", v.RET_RED)
			IEEEParse.Pcap_parser_OFFLINE(a, "RCPT TO")
			IEEEParse.Pcap_parser_OFFLINE(a, "MAIL FROM")
		} else {
			IEEEParse.Pcap_parser_OFFLINE(flags_rr6.Filepath_general, "RCPT TO")
			IEEEParse.Pcap_parser_OFFLINE(flags_rr6.Filepath_general, "MAIL FROM")
		}
	case "dump pcap sipa":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to SIP/net Pcap File> ", v.RET_RED)
			fmt.Println("[ >>>>> ] Username ")
			IEEEParse.Pcap_parser_OFFLINE_byte(a, "USER")
			fmt.Println("[ >>>>> ] Password ")
			IEEEParse.Pcap_parser_OFFLINE_byte(a, "PASS")
		} else {
			fmt.Println("[ >>>>> ] Username ")
			IEEEParse.Pcap_parser_OFFLINE_byte(flags_rr6.Filepath_general, "USER")
			fmt.Println("[ >>>>> ] Password ")
			IEEEParse.Pcap_parser_OFFLINE_byte(flags_rr6.Filepath_general, "PASS")
		}
	case "dump pcap sipok":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to SIP/net Pcap File> ", v.RET_RED)
			IEEEParse.Pcap_parser_OFFLINE_byte(a, "+OK")
		} else {
			IEEEParse.Pcap_parser_OFFLINE_byte(flags_rr6.Filepath_general, "+OK")
		}
	case "dump pcap sipinv":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to SIP/Net Pcap File> ", v.RET_RED)
			IEEEParse.Pcap_parser_OFFLINE_byte(a, "INVITE")
		} else {
			IEEEParse.Pcap_parser_OFFLINE_byte(flags_rr6.Filepath_general, "INVITE")
		}
	case "dump pcap sipreg":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to SIP/Net Pcap File> ", v.RET_RED)
			IEEEParse.Pcap_parser_OFFLINE_byte(a, "REGISTERS")
		} else {
			IEEEParse.Pcap_parser_OFFLINE_byte(flags_rr6.Filepath_general, "REGISTERS")
		}
	case "dump pcap sippg":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to SIP/Net Pcap File> ", v.RET_RED)
			IEEEParse.Pcap_parser_OFFLINE(a, "POST")
			IEEEParse.Pcap_parser_OFFLINE(a, "GET")
		} else {
			IEEEParse.Pcap_parser_OFFLINE(flags_rr6.Filepath_general, "POST")
			IEEEParse.Pcap_parser_OFFLINE(flags_rr6.Filepath_general, "GET")
		}
	case "dump pcap imaplogn":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to IMAP/Net Pcap File> ", v.RET_RED)
			IEEEParse.Pcap_parser_OFFLINE(a, "LOGIN")
		} else {
			IEEEParse.Pcap_parser_OFFLINE(flags_rr6.Filepath_general, "LOGIN")
		}
	case "dump pcap images":
		if flags_rr6.Filepath_general == "" {
			a := sio("Path to PCAP file > ", v.RET_RED)
			fmt.Println(v.YEL, "[!] Warning: Filepath must have / at the end")
			b := sio("output directory  > ", v.RET_RED)
			IEEEParse.Run_CPP(a, b, "modules/go-main/80211/main")
		} else {
			a := sio("Enter a output path> ", v.RET_RED)
			IEEEParse.Run_CPP(flags_rr6.Filepath_general, a, "modules/go-main/80211/main")
		}
	case "dump pcap custom":
		fmt.Println("SMTP DEFUALT PARAMS")
		fmt.Println("\033[49m")
		fmt.Println(constants.Paramaters_SMTP)
		fmt.Println("--------------------------")
		fmt.Println("SMTP PLAIN AUTH DEFUALT PARAMS")
		fmt.Println("\033[49m")
		fmt.Println(constants.Paramaters_SMTP_plain)
		fmt.Println("--------------------------")
		fmt.Println("HTTP PARAMATERS")
		fmt.Println("\033[49m")
		fmt.Println(constants.Paramaters_HTTP)
		fmt.Println("--------------------------")
		fmt.Println("HTTP IMAGE DEFUALT PARAMS")
		fmt.Println("\033[49m")
		fmt.Println(constants.Paramaters_HTTP_img)
		fmt.Println("--------------------------")
		fmt.Println("IMAP PLAIN TEXT DEFUALT PARAMS")
		fmt.Println("\033[49m")
		fmt.Println(constants.Paramaters_IMAP_PLAIN_TEXT)
		fmt.Println("--------------------------")
		fmt.Println("\033[49m")
		fmt.Println(v.RED, "SIP Paramaters")
		fmt.Println(constants.Paramaters_SIP)
		fmt.Printf("\n\n\n Note: You can add your own values, \nhowever this is just a simple help menu to guide you in the right direction :> \n")
		fmt.Println("#############################################################")
		opt := sio("Enter a value or paramater to parse      (1) allowed >>> ", v.BLKHB)
		if flags_rr6.Filepath_general == "" {
			f := sio("Enter the path to the network pcap file  (1) allowed >>> ", v.BLKHB)
			IEEEParse.Pcap_parser_OFFLINE_byte(f, opt)
		} else {
			IEEEParse.Pcap_parser_OFFLINE_byte(flags_rr6.Filepath_general, opt)
		}
	case "dump pcap":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter the filepath to the PCAP file (1) allowed >>>> ", v.BLKHB)
			IEEEParse.Parser(a)
		} else {
			IEEEParse.Parser(flags_rr6.Filepath_general)
		}
	//*************************************************************************************
	//*          This break concludes the Offline PCAP parsing and file parsers           *
	//*                                                                                   *
	//*************************************************************************************
	case "Brute psql":
		wordlist := sio("Enter a wordlist\t |> ", v.RET_RED)
		username := sio("Enter a user    \t |> ", v.RET_RED)
		dbname := sio("Enter db name   \t |> ", v.RET_RED)
		hostname := sio("Enter a host    \t |> ", v.RET_RED)
		threadc := iio("Enter threads   \t |> ", v.RET_RED)
		SQL.Parse_Server(username, wordlist, hostname, dbname, "postgresql", threadc)
	case "Brute mongo":
		wordlist := sio("Enter a wordlist\t |> ", v.RET_RED)
		username := sio("Enter a user    \t |> ", v.RET_RED)
		hostname := sio("Enter a host    \t |> ", v.RET_RED)
		threadc := iio("Enter threads   \t |> ", v.RET_RED)
		SQL.Parse_Server(username, wordlist, hostname, "", "mongo", threadc)
	case "Brute mysql":
		wordlist := sio("Enter a wordlist\t |> ", v.RET_RED)
		username := sio("Enter a user    \t |> ", v.RET_RED)
		dbname := sio("Enter db name   \t |> ", v.RET_RED)
		hostname := sio("Enter a host    \t |> ", v.RET_RED)
		threadc := iio("Enter threads   \t |> ", v.RET_RED)
		SQL.Parse_Server(username, wordlist, hostname, dbname, "mysql", threadc)
	case "Brute SMTP":
		if flags_rr6.Brute_list == "" {
			a := sio("Enter a filepath to the wordlist you want to use> \033[39m", v.BLKHB)
			e := sio("Enter a email service to brute force> \033[39m", v.BLKHB)
			i := sio("Enter a email to brute force> \033[39m", v.BLKHB)
			brutes.Brute_SMTP(a, i, e)
		} else {
			e := sio("Enter a email service to brute force> \033[39m", v.BLKHB)
			i := sio("Enter a email to brute force> \033[39m", v.BLKHB)
			brutes.Brute_SMTP(flags_rr6.Brute_list, i, e)
		}
	case "Brute SSH":
		if flags_rr6.Brute_list == "" {
			a := sio("Enter an SSH Host> \033[39m\033[49m", v.BLKHB)
			b := sio("Enter an SSH User> \033[39m\033[49m", v.BLKHB)
			c := sio("Enter a Wordlist > \033[39m\033[49m", v.BLKHB)
			p := sio("Enter a SSH Port > \033[39m\033[49m", v.BBLK)
			brutes.Brute_SSH_(b, c, a, p)
		} else {
			a := sio("Enter an SSH Host> \033[39m", v.BLKHB)
			b := sio("Enter an SSH User> \033[39m", v.BLKHB)
			p := sio("Enter a SSH Port > \033[39m\033[49m", v.BBLK)
			brutes.Brute_SSH_(b, flags_rr6.Brute_list, a, p)
		}
	case "Brute FTP":
		if flags_rr6.Brute_list == "" {
			a := sio("Enter a FTP Host> \033[39m", v.BLKHB)
			B := sio("Enter a FTP User> \033[39m", v.BLKHB)
			C := sio("Enter a Wordlist> \033[39m", v.BLKHB)
			P := sio("Enter FTP Port  > \033[39m", v.BLKHB)
			brutes.Brute_FTP(B, C, a, P)
		} else {
			a := sio("Enter a FTP Host> \033[39m", v.BLKHB)
			B := sio("Enter a FTP User> \033[39m", v.BLKHB)
			P := sio("Enter a FTP Port> \033[39m", v.BLKHB)
			brutes.Brute_FTP(B, flags_rr6.Brute_list, a, P)
		}
	case "Brute HTTPA":
		if flags_rr6.Brute_list == "" {
			a := sio("Enter a URL> \033[39m", v.BLKHB)
			b := sio("Enter a Wordlist> \033[39m", v.BLKHB)
			c := sio("Enter a Username> \033[39m", v.BLKHB)
			brutes.Brute_BASIC_HTTP_AUTH(a, b, c, 2)
		} else {
			a := sio("Enter a URL> \033[39m", v.BLKHB)
			c := sio("Enter a Username> \033[39m", v.BLKHB)
			brutes.Brute_BASIC_HTTP_AUTH(a, flags_rr6.Brute_list, c, 2)
		}
	case "Brute HTTP auth":
		a := sio("Enter a URL> \033[39m", v.BLKHB)
		c := sio("Enter a Username> \033[39m", v.BLKHB)
		Brute_Utils.Run(a, flags_rr6.Brute_list, c)
	case "Brute Telnet":
		a := sio("Enter a Hostname> \033[39m\033[49m", v.BLKHB)
		b := sio("Enter a Wordlist> \033[39m\033[49m", v.BLKHB)
		c := sio("Enter a Username> \033[39m\033[49m", v.BLKHB)
		p := "perl"
		p1 := "r6.pl"
		p00 := "-o"
		arg00 := "brute_telnet"
		p2 := "-f"
		arg := b
		p3 := "-u"
		arg1 := c
		p4 := "-t"
		arg2 := a
		exe := exec.Command(p, p1, p00, arg00, p2, arg, p3, arg1, p4, arg2)
		fmt.Println("[*] Executed....\nSilencing Output......")
		fmt.Println("[!] IF this takes too long CTRL+C is key to SIGINT ( Signal Interrupt )")
		stdout, e := exe.Output()
		if e != nil {
			log.Fatal(e)
		}
		fmt.Println("Racing....")
		fmt.Print(string(stdout))
	case "Brute Cpan":
		a := sio("Enter a host IPA> ", v.BLKHB)
		b := sio("Enter a Username> ", v.BLKHB)
		c := sio("Enter a CPANPort> ", v.BLKHB)
		d := sio("Enter a Wordlist> ", v.BLKHB)
		p := "perl"
		p1 := constants.Perl_CPAN_Brute
		p00 := "-h"
		arg00 := a
		p2 := "-u"
		arg := b
		p3 := "-p"
		arg1 := c
		p4 := "-l"
		arg2 := d
		exe := exec.Command(p, p1, p00, arg00, p2, arg, p3, arg1, p4, arg2)
		fmt.Println(v.REDHB, "[*] Executed....\nSilencing Output......", v.RET_RED)
		fmt.Println("[!] IF this takes too long CTRL+C is key to SIGINT ( Signal Interrupt )")
		stdout, e := exe.Output()
		if e != nil {
			log.Fatal(e)
		}
		fmt.Println("Racing....")
		fmt.Print(string(stdout))
	case "Brute ZIP":
		if flags_rr6.Filepath_general == "" || flags_rr6.Brute_list == "" {
			Filename := sio("Enter the full filepath of the ZIP file    -> ", v.HIGH_BLUE)
			Wordlist := sio("Enter the full filepath of the wordlist    -> ", v.HIGH_PINK)
			var Workers int
			Workers = iio("Enter the number of workers to use         -> ", v.HIGH_BLUE)
			if Workers == 0 {
				Workers = runtime.NumCPU()
			}
			password := Brute_Utils.ZIP_CRACK(Filename, Wordlist, Workers)
			if password != "" {
				fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Password found for the ZIP file -> ", password)
				fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Password found for the ZIP file -> ", password)
				contin := sio("Press enter to continue or exit to exit -> ", v.RET_RED)
				if contin == "exit" || contin == "e" || contin == "bye" {
					os.Exit(0)
				}
			} else {
				fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Password NOT found for the given ZIP file :(")
				fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Password found for the ZIP file -> ", password)
				contin := sio("Press enter to continue or exit to exit -> ", v.RET_RED)
				if contin == "exit" || contin == "e" || contin == "bye" {
					os.Exit(0)
				}
			}
		} else {
			var Workers int
			Workers = iio("Enter the number of workers to use         -> ", v.HIGH_BLUE)
			if Workers == 0 {
				Workers = runtime.NumCPU()
			}
			password := Brute_Utils.ZIP_CRACK(flags_rr6.Filepath_general, flags_rr6.Brute_list, Workers)
			if password != "" {
				fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Password found for the ZIP file -> ", password)
				contin := sio("Press enter to continue or exit to exit -> ", v.RET_RED)
				if contin == "exit" || contin == "e" || contin == "bye" {
					os.Exit(0)
				}
			} else {
				fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Password NOT found for the given ZIP file :(")
				fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Password found for the ZIP file -> ", password)
				contin := sio("Press enter to continue or exit to exit -> ", v.RET_RED)
				if contin == "exit" || contin == "e" || contin == "bye" {
					os.Exit(0)
				}
			}
		}

	//*************************************************************************************
	//*          This break concludes the Online brute forcing attack modules             *
	//*                                                                                   *
	//*************************************************************************************
	case "sniff interfaces":
		IEEE.HOME_Interfaces()
	case "sniff interface ip":
		a := sio("Enter a possible IP> ", v.RET_RED)
		interface_cpp_utils.Run_CPP("run", a, "addr_NIL", "modules/go-main/80211/interface", "yes")
	case "sniff iface info *":
		a := IEEE.HOME_Interfaces_return_list()
		for _, i := range a {
			system_interface_utils.Recon(i)
		}
	case "sniff iface info":
		a := sio("Enter an interface to grab info from>> ", v.RET_RED)
		system_interface_utils.Recon(a)
	case "sniff application":
		if flags_rr6.Sniffc == "" {
			Parse_options_for_netcap("app", true, "")
		} else {
			Parse_options_for_netcap("app", false, flags_rr6.Sniffc)
		}
	case "sniff tcp":
		if flags_rr6.Sniffc == "" {
			Parse_options_for_netcap("tcp", true, "")
		} else {
			Parse_options_for_netcap("tcp", false, flags_rr6.Sniffc)
		}
	case "sniff icmp":
		if flags_rr6.Sniffc == "" {
			Parse_options_for_netcap("icmp", true, "")
		} else {
			Parse_options_for_netcap("icmp", false, flags_rr6.Sniffc)
		}
	case "sniff ip":
		if flags_rr6.Sniffc == "" {
			Parse_options_for_netcap("ip", true, "")
		} else {
			Parse_options_for_netcap("ip", false, flags_rr6.Sniffc)
		}
	case "sniff dhcp":
		if flags_rr6.Sniffc == "" {
			Parse_options_for_netcap("dhcmp", true, "")
		} else {
			Parse_options_for_netcap("dhcmp", false, flags_rr6.Sniffc)
		}
	case "sniff ethernet":
		if flags_rr6.Sniffc == "" {
			Parse_options_for_netcap("eth", true, "")
		} else {
			Parse_options_for_netcap("eth", false, flags_rr6.Sniffc)
		}
	case "sniff ftp_cred":
		if flags_rr6.Sniffc == "" {
			a := sio("Enter a interface to use> ", v.RET_RED)
			IEEE_Sniff.Ftp_starter_credential_Applayer(1024, "tcp port 110 or tcp port 25 or tcp port 143", a)
		} else {
			IEEE_Sniff.Ftp_starter_credential_Applayer(1024, "tcp port 110 or tcp port 25 or tcp port 143", flags_rr6.Sniffc)
		}
	case "sniff smtp_cred":
		if flags_rr6.Sniffc == "" {
			a := sio("Enter a interface to use> ", v.RET_RED)
			IEEE_Sniff.Smtp_Starter_crednetial_listener(1024, "tcp port 110 or tcp port 25 or tcp port 143", a)
		} else {
			IEEE_Sniff.Smtp_Starter_crednetial_listener(1024, "tcp port 110 or tcp port 25 or tcp port 143", flags_rr6.Sniffc)
		}
	case "sniff ssid": // sniff SSID's, BSSID's, Frequencies, OUI's etc through probe requests
		if flags_rr6.Sniffc == "" {
			inter := sio("Enter a interface to use> ", v.BLU)
			runner_802.Run(inter, "airodump")
		} else {
			fmt.Println(flags_rr6.Sniffc)
			runner_802.Run(flags_rr6.Sniffc, "airodump")
		}
	case "sniff probe":
		if flags_rr6.Sniffc == "" {
			inter := sio("Enter a interface to use> ", v.BLU)
			runner_802.Run(inter, "probereq")
		} else {
			fmt.Println(flags_rr6.Sniffc)
			runner_802.Run(flags_rr6.Sniffc, "probereq")
		}
	case "sniff 802raw": // sniff raw unparsed 802.11 packets
		if flags_rr6.Sniffc == "" {
			inter := sio("Enter a interface to use> ", v.BLU)
			runner_802.Run(inter, "normal")
		} else {
			fmt.Println(flags_rr6.Sniffc)
			runner_802.Run(flags_rr6.Sniffc, "normal")
		}
	case "sniff discovery":
		if flags_rr6.Sniffc == "" {
			inter := sio("Enter a interface to use> ", v.BLU)
			runner_802.Run(inter, "discover")
		} else {
			fmt.Println(flags_rr6.Sniffc)
			runner_802.Run(flags_rr6.Sniffc, "discover")
		}

	//*********************************************************************************************************
	//*          This break concludes the Online network attacks/sniffing and credential sniffers             *
	//*                                                                                                       *
	//*********************************************************************************************************
	case "check IP":
		a := sio("Enter a IP> ", v.RET_RED)
		osintutils.Get_IP(a)
	case "check github orgr":
		a := sio("Enter a Organization name> ", v.RET_RED)
		GIT_Utils.Get_All_Organization_Repos(a)
	case "check github usero":
		a := sio("Enter a username> ", v.RET_RED)
		GIT_Utils.Get_ALl_Org_Events(a)
	case "check github usere":
		a := sio("Enter a username> ", v.RET_RED)
		GIT_Utils.Get_All_Events_from_user(a)
	case "check github orge":
		a := sio("Enter a Organization name> ", v.RET_RED)
		GIT_Utils.Get_All_Events_from_organization(a)
	case "check github user":
		user := sio("Enter a github Username> ", v.RET_RED)
		GIT_Utils.Get_USER_INFO(user)
	case "check github star":
		username := sio("Enter the repo owner> ", v.RET_RED)
		repository := sio("Enter the repo name> ", v.RET_RED)
		GIT_Utils.Get_All_REPO_Stargazers_Information(username, repository)
	case "check github foll":
		username := sio("Enter the github username> ", v.RET_RED)
		GIT_Utils.Get_users_followers(username)
	case "check github repos":
		username := sio("Enter the github username> ", v.RET_RED)
		GIT_Utils.Get_All_User_Repos_Information(username)
	/////
	case "check cpanel vuln":
		execute.Run("perl", "modules/op-sec/CPANEL/cpan.pl")
	case "check azure ip":
		ipa := sio("Enter a IP>> ", v.BLU)
		azure.Check_ip("json/Azure.json", ipa)
	case "check proton ip":
		ipa := sio("Enter a IP>> ", v.GRN)
		osintutils.Test_if_IP_Is_proton(ipa)
	case "check proton email":
		email := sio("Enter an email>> ", v.GRN)
		osintutils.Test_if_email_Is_proton(email)
	case "check cloudflare ip":
		ip := sio("Enter a IP>> ", v.BBLU)
		osintutils.Test_if_IP_Is_CLOUDFLARE(ip)
	case "check aws ip":
		ip := sio("Enter a IP>> ", "\033[39m")
		osintutils.Test_if_IP_Is_AWS(ip)
	case "check cloudfront ip":
		ip := sio("Enter a IP>> ", "\033[39m")
		cloudfront_utils.Compare(ip)
	case "check mcafe ip":
		ip := sio("Enter a IP>> ", "\033[39m")
		mcafe_utils.Output_test(ip)
	case "check myip":
		osintutils.Test_Public_addr()
	case "check number":
		a := sio("Enter a Number hash>> ", "\033[39m")
		phone_utils.Parser(a)
	case "check number us":
		a := sio("Enter a Number hash>> ", "\033[39m")
		phone_utils.Parser_US(false, a)
	case "trace number us":
		a := sio("Enter the first 3 numbers >> ", "\033[39m")
		b := sio("Enter the second 3 numbers >> ", "\033[39m")
		c := sio("Enter the last 4 numbers   >> ", "\033[39m")
		system.Run_number(a, b, c)
	case "check number be":
		a := sio("Enter a number hash>> ", "\033[39m")
		phone_utils.Parser_BE(a)
	case "check username":
		a := sio("Enter a username>> ", "\033[39m")
		osintutils.Test_Username_Site(a, "config/urllist_user.txt")
	case "check ip2":
		a := sio("Enter a IP>> ", v.RET_RED)
		osintutils.Trace_IP_Secondary_API(a)
	// extra utilities NOTE( I WILL UPDATE THE DUMB WAY THE FLAGS ARE SET, IT WILL DO FOR RIGHT NOW )
	case "parse ssh config":
		yml_utils.Parse_File_ssh("config/services/ssh.yaml")
	case "parse config":
		api_utils.Reader("config/api_key.conf")
	case "parse burp targets":
		a := sio("Enter a list of URL's>> ", "\033[39m")
		b := sio("Enter a output json file (ex:name.json)>> ", "\033[39m")
		file_utils.Generate_Burp_Config(a, b)
	case "parse xmln host":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "host")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "host")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "host")
			}
		}
	case "parse xmln service":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "service info")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "service info")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "service info")
			}
		}
	case "parse xmln ports":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "ports")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "ports")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "ports")
			}
		}
	case "parse xmln hostn":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "hostnames")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "hostnames")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "hostnames")
			}
		}
	case "parse xmln porti":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "port info")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "port info")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "port info")
			}
		}
	case "parse xmln runs":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "Runstats")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "Runstats")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "Runstats")
			}
		}
	case "parse xmln hosts":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "hosts")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "hosts")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "hosts")
			}
		}
	case "parse xmln hosth":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "Host Hint")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "Host Hint")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "Host Hint")
			}
		}
	case "parse xmln debug":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "debug")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "debug")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "debug")
			}
		}
	case "parse xmln verbose":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "verbose")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "verbose")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "verbose")
			}
		}
	case "parse xmln scaninf":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "scan info")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "scan info")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "scan info")
			}
		}
	case "parse xmln times":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "scan info")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "scan time")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "scan time")
			}
		}
	case "parse xmln *":
		if flags_rr6.XML_file == "" {
			a := sio("Enter a NMAP XML Filepath>> ", "\033[39m")
			xml_utils.Main(a, "*")
		} else {
			if flags_rr6.Filepath_general == "" {
				xml_utils.Main(flags_rr6.XML_file, "*")
			} else {
				xml_utils.Main(flags_rr6.Filepath_general, "*")
			}
		}
	case "parse data mac":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a filename> ", color.RET_RED)
			output := regex.Open_file(a, "^(((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2})$|^(((\\d|([a-f]|[A-F])){2}-){5}(\\d|([a-f]|[A-F])){2})$|^$")
			fmt.Println(output)
		} else {
			output := regex.Open_file(flags_rr6.Filepath_general, "^(((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2})$|^(((\\d|([a-f]|[A-F])){2}-){5}(\\d|([a-f]|[A-F])){2})$|^$")
			fmt.Println(output)
		}
	case "parse data email":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a filename> ", color.RET_RED)
			output := regex.Open_file(a, "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$")
			fmt.Println(output)
		} else {
			output := regex.Open_file(flags_rr6.Filepath_general, "^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$")
			fmt.Println(output)
		}
	case "parse data IP4":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a filename> ", color.RET_RED)
			output := regex.Open_file(a, "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.){3}(25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)$")
			fmt.Println(output)
		} else {
			output := regex.Open_file(flags_rr6.Filepath_general, "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.){3}(25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)$")
			fmt.Println(output)
		}
	case "parse data IP6":
		if flags_rr6.Filepath_general == "" {
			a := sio("Enter a filename> ", color.RET_RED)
			output := regex.Open_file(a, "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.){3}(25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)$")
			fmt.Println(output)
		} else {
			output := regex.Open_file(flags_rr6.Filepath_general, "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.){3}(25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)$")
			fmt.Println(output)
		}
	case "parse scope":
		a := sio("Enter a file of URL's> ", color.RET_RED)
		jf := sio("Enter the scope json file> ", color.RET_RED)
		burp_PARSER.Call(a, jf)
	case "utils gen qr":
		a := sio("Enter a url to embed> ", v.RET_RED)
		b := sio("Enter a output img name> ", v.RET_RED)
		QR_UTILS.Generate(a, b)
	case "utils gen qrl":
		a := sio("Enter a list of URLS to generate> ", v.RET_RED)
		f, x := os.Open(a)
		if x != nil {
			fmt.Println("<RR6> File I/O: Could not open, read, or locate file, got error -> ", x)
		} else {
			defer f.Close()
			scanner := bufio.NewScanner(f)
			for scanner.Scan() {
				fmt.Println(v.HIGH_BLUE, "######## NEW DATA SEGMENT FOR URL -> ", scanner.Text())
				PHOTO_ID := id_generation.ShortID(5)
				fmt.Println(v.HIGH_BLUE, "> PHOTO ID   : ", PHOTO_ID+".png", " Has URL -> ", scanner.Text())
				fmt.Println(v.HIGH_BLUE, "> PHOTO NAME : ", scanner.Text()+".png", " Has url -> ", scanner.Text())
				parser := PHOTO_ID + ".png"
				QR_UTILS.Generate(parser, scanner.Text())
			}
		}
	case "utils gen AES":
		key := sio("Enter a key you want to set     -> ", v.RET_RED)
		pas := sio("Enter the text you want to set  -> ", v.RET_RED)
		fil := sio("Enter an output filename to set -> ", v.RET_RED)
		k := []byte(key)
		p := []byte(pas)
		AES.Enc_Msg(k, p, fil)
	case "utils dec AES":
		key := sio("Enter the key           -> ", v.RET_RED)
		data := sio("Enter the file of data -> ", v.RET_RED)
		k := []byte(key)
		AES.Dec_data(k, data)
	case "utils encf AES":
		// key file
		kf := sio("Enter a path to the AES key file             -> ", v.RET_RED)
		ef := sio("Enter a path to the file you want to encrypt -> ", v.RET_RED)
		kd, x := ioutil.ReadFile(kf)
		if x != nil {
			fmt.Println(v.REDHB, "<RR6> Encryption -> AES Module: Could not open key file, got error when using i/o to open and read all contents of the given file -> ", x)
			os.Exit(0)
		}
		kted, x := ioutil.ReadFile(ef)
		if x != nil {
			fmt.Println(v.REDHB, "<RR6> Encryption -> AES module: Could not open the contents of the file you would like to encrypt, got error when using the i/o utils to read file -> ", x, " [ EXITING WITH STATUS 0, RE RUN RED RABBIT ] ")
			os.Exit(0)
		}
		msg, xx := AES.Enc(kd, kted)
		if xx != 0x00 {
			fmt.Println(v.REDHB, "<RR6> Encryption -> AES module: Got error when trying to encrypt the file data from the I/o STD reader, during running AES.enc function -> ", x)
		} else {
			fmt.Printf("[*] Enc MSG ??? %s\n", msg)
		}
	case "utils decf AES":
		kf := sio("Enter a path to the AES key file             -> ", v.RET_RED)
		ef := sio("Enter a path to the file you want to encrypt -> ", v.RET_RED)
		kd, x := ioutil.ReadFile(kf)
		if x != nil {
			fmt.Println(v.REDHB, "<RR6> Encryption -> AES Module: Could not open key file, got error when using i/o to open and read all contents of the given file -> ", x)
			os.Exit(0)
		}
		kted, x := ioutil.ReadFile(ef)
		if x != nil {
			fmt.Println(v.REDHB, "<RR6> Encryption -> AES module: Could not open the contents of the file you would like to encrypt, got error when using the i/o utils to read file -> ", x, " [ EXITING WITH STATUS 0, RE RUN RED RABBIT ] ")
			os.Exit(0)
		}
		msg, xx := AES.Dec(kd, kted)
		if xx != 0x00 {
			fmt.Println(v.REDHB, "<RR6> Encryption -> AES module: Got error when trying to encrypt the file data from the I/o STD reader, during running AES.enc function -> ", x)
		} else {
			fmt.Printf("[*] Enc MSG ??? %s\n", msg)
		}
	case "utils msfsessions":
		MSF.Run()
	case "utils gen xxe php":
		ENVIRON.Generate("phpcmd")
	case "utils gen xxe soap":
		ENVIRON.Generate("SOAP")
	case "utils gen xxe base":
		ENVIRON.Generate("base64")
	case "utils gen xxe inj":
		ENVIRON.Generate("injection")
	case "utils gen xxe xinc":
		ENVIRON.Generate("XINCLUDE")
	case "utils deface htm":
		filep := sio("Enter the filepath of HTML files -> ", v.HIGH_PINK)
		fmt.Println(v.WHT)
		execute.Defacer_(filep)
	case "utils test binary":
		a := sio("Enter the path to the binary file -> ", v.HIGH_BLUE)
		execute.BOF(a)
	case "utils gen linkmail":
		a := sio("Enter a URL> ", v.RET_RED)
		fmt.Print(v.HIGH_BLUE)
		malt_utils.Get_Links_FORM_(a)
	case "utils gen emailmail":
		fmt.Print(v.HIGH_BLUE)
		a := sio("Enter a URL> ", v.RET_RED)
		malt_utils.Get_Emails_FORM_(a)
	case "utils shodan":
		a := sio("Enter a shodan API Key> ", v.RET_RED)
		b := sio("Enter a service  to lookup> ", v.REDHB)
		SUPER_Shodan_UTILS.Run(a, b)
	case "utils gen rjpg":
		PHOTO_ID := id_generation.ShortID(5)
		simple_super.Generate(PHOTO_ID)
	case "utils unzip":
		a := sio("Enter a file to unzip> ", v.RET_RED)
		UNZIP_SUPER_UTILS.Run(a)
	case "utils gz uncompress":
		a := sio("Enter a filename> ", v.RET_RED)
		gzip_decoder.Run(a)
	case "utils ghosted":
		fmt.Println(system_utils_ghosted_Shell.Clear_hex)
		system_utils_ghosted_Shell.Ascii()
		system_utils_ghosted_Shell.Console(v.BHRED, "\t\t\t\t")
	case "utils blocker l":
		a := sio("Enter a filename of hosts>>> ", v.RET_RED)
		dns.Parse_Settings("", a, true)
	case "utils blocker s":
		a := sio("Enter a URL to block>>> ", v.RET_RED)
		dns.Parse_Settings(a, "", false)
	case "utils blocker fix":
		dns.Repair_File()
	case "utils build gmapl":
		a := iio32("Enter a LAT \t |> ", v.RET_RED)
		b := iio32("Enter a LON \t |> ", v.RET_RED)
		fmt.Printf("\n\033[0;35m\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| GPS Map   \033[38;5;21m: https://www.google.com/maps/@%v,%v\n", a, b)
	case "utils verify mac":
		a := sio("Enter a MAC> ", v.RET_RED)
		if !regex.Regex("^(((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2})$|^(((\\d|([a-f]|[A-F])){2}-){5}(\\d|([a-f]|[A-F])){2})$|^$", a) {
			fmt.Println(v.REDHB, "[-] Not a valid mac address: -> Came back false...\033[39m\033[49m\033[31m", v.RET_RED)
		} else {
			fmt.Println(v.BLUHB, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Is a valid mac address: -> Ready to be tested...\033[39m\033[49m\033[31m", v.RET_RED)
		}
	case "utils verify email":
		a := sio("Enter a email> ", v.RET_RED)
		if !regex.Regex("^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$", a) {
			fmt.Println(v.REDHB, "[-] Not a valid email address: -> Came back false...\033[39m\033[49m\033[31m", v.RET_RED)
		} else {
			fmt.Println(v.BLUHB, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Is a valid email address: -> Ready to be tested...\033[39m\033[49m\033[31m", v.RET_RED)
		}
	case "utils verify IP4":
		a := sio("Enter a IPv4 Address> ", v.RET_RED)
		if !regex.Regex("^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.){3}(25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)$", a) {
			fmt.Println(v.REDHB, "[-] Not a valid IPv4 address: -> Came back false...\033[39m\033[49m\033[31m", v.RET_RED)
		} else {
			fmt.Println(v.BLUHB, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Is a valid IPv4 address: -> Ready to be tested...\033[39m\033[49m\033[31m", v.RET_RED)
		}
	case "utils verify IP6":
		a := sio("Enter a IPv6 Address> ", v.RET_RED)
		if !regex.Regex("(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))", a) {
			fmt.Println(v.REDHB, "[-] Not a valid IPv6 address: -> Came back false...\033[39m\033[49m\033[31m", v.RET_RED)
		} else {
			fmt.Println(v.BLUHB, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Is a valid IPv6 address: -> Ready to be tested...\033[39m\033[49m\033[31m", v.RET_RED)
		}
	case "utils verify h:p":
		fmt.Print("\n")
		fmt.Println("Example: www.google.com:27015")
		a := sio("Enter a host and a port> ", v.RET_RED)
		if !regex.Regex("([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\:[0-9]{5})|([a-z]+\\.[a-z]+\\.[a-z]+\\:[0-9]{5})", a) {
			fmt.Println(v.REDHB, "[-] Not a valid host: -> Came back false...\033[39m\033[49m\033[31m", v.RET_RED)
		} else {
			fmt.Println(v.BLUHB, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Is a valid host address: -> Ready to be tested...\033[39m\033[49m\033[31m", v.RET_RED)
		}
	case "utils verify host":
		//(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}
		a := sio("Enter a host> ", v.RET_RED)
		if !regex.Regex("(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}", a) {
			fmt.Println(v.REDHB, "[-] Not a valid host: -> Came back false...\033[39m\033[49m\033[31m", v.RET_RED)
		} else {
			fmt.Println(v.BLUHB, "\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Is a valid host address: -> Ready to be tested...\033[39m\033[49m\033[31m", v.RET_RED)
		}
	case "utils gen JPG":
		if flags_rr6.Input == "" {
			a := sio("Enter a JPG image> ", v.MAG)
			MAGIC_TESTER.Test_Image(a)
		} else {
			MAGIC_TESTER.Test_Image(flags_rr6.Input)
		}
	case "utils gen map":
		a := iio32("Enter the latitude > ", v.RET_RED)
		b := iio32("Enter the longitude> ", v.RET_RED)
		name := id_generation.ShortID(6)
		fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Setting   : -> Name", name)
		MAGIC_TESTER.Generate_MAP(name, a, b)
	case "utils tor stat":
		ENVIRON.Test()
	case "utils tor down":
		URL := sio("Enter the url to download the file from -> ", v.RET_RED)
		PATH := sio("Enter the path to save it to (must have / at the end) -> ", v.RET_RED)
		ENVIRON.Download_File_TOR(URL, PATH)
	// ssh
	case "ssh check":
		a := sio("Enter a host -> ", v.RET_RED)
		b, x := ssh_utils.Check_Port(a)
		if x != nil {
			fmt.Println(x)
		} else {
			fmt.Println(b)
		}
	case "ssh dial":
		a := sio("Enter a host -> ", v.BLU)
		c, _ := ssh_utils.Make_Request(a)
		fmt.Println(c)
	case "ssh auth":
		a := sio("Enter a host -> ", v.BLU)
		b := sio("Enter a user -> ", v.BLU)
		c := sio("Enter a pass -> ", v.BLU)
		p, x := ssh_utils.Make_Auth(b, c, a)
		if x != nil {
			fmt.Println(v.REDHB, x, v.RET_RED)
			fmt.Println("<RR6> Response Module: This may mean the connection has failed or the password has failed.....")
		}
		fmt.Println(p)
	case "ssh auth key":
		a := sio("Enter a user    |-> ", v.BLU)
		b := sio("Enter a pass    |-> ", v.BLU)
		c := sio("Enter a host    |-> ", v.BLU)
		d := sio("Enter a port    |-> ", v.BLU)
		e := sio("Enter a keyfile |-> ", v.BLU)
		ssh_utils.Private_Auth(a, b, c, d, e)
	case "ssh exec":
		a := sio("Enter a user     |-> ", v.BLU)
		b := sio("Enter a pass     |-> ", v.BLU)
		c := sio("Enter a host     |-> ", v.BLU)
		d := sio("Enter a port     |-> ", v.BLU)
		co := sio("Enter a command |-> ", v.BLU)
		ssh_utils.Exec_SSH(co, b, a, d, c)
	case "ssh auth config":
		host, password, port, username, filename := yml_utils.Parse_return("config/services/ssh.yaml")
		ssh_utils.Private_Auth(username, password, host, port, filename)
	case "ssh dial config":
		host, _, _, _, _ := yml_utils.Parse_return("config/services/ssh.yaml")
		ssh_utils.Make_Request(host)
	case "ssh check config":
		Host, _, _, _, _ := yml_utils.Parse_return("config/services/ssh.yaml")
		ssh_utils.Check_Port(Host)
	case "ssh transfer":
		filename := sio("Enter a file to transfer |-> ", v.BLU)
		username := sio("Enter a username to set  |-> ", v.BLU)
		hostname := sio("Enter a hostname to set  |-> ", v.BLU)
		ssh_utils.SCP_ssh(filename, username, hostname)
		// this is not really an interactive shell but its a simple shell for easy access
	case "ssh start shell":
		a := sio("Enter a user     |-> ", v.BLU)
		c := sio("Enter a host     |-> ", v.BLU)
		d := sio("Enter a keyfile  |-> ", v.BLU)
		s := sio("Enter the os (windows / linux) > ", v.BLU)
		h := iio("Enter the window height > ", v.BLU)
		w := iio("Enter the window width  > ", v.BLU)
		SUPER_SSH.SSH_Shell(a, c, d, s, h, w)
	// databases, MSSQL, MYSQL, PostGreSQl, Mongo etc
	case "db ping mongo":
		a := sio("Enter a IP/Hostname> ", color.HIGH_BLUE)
		SQL.Ping_DB_3(a, "Mongo")
	case "db ping mysql":
		a := sio("Enter a IP/Hostname> ", color.HIGH_BLUE)
		SQL.Ping_DB_3(a, "MySQL")
	case "db ping postgres":
		a := sio("Enter a IP/Hostname> ", color.HIGH_BLUE)
		SQL.Ping_DB_3(a, "PostGreSQl")
	case "db ping mssql":
		a := sio("Enter a IP/Hostname> ", color.HIGH_BLUE)
		SQL.Ping_DB_3(a, "MSSQL")
	case "db auth mysql":
		a := sio("Enter a IP/Hostname> ", color.HIGH_PINK)
		b := sio("Enter a Username   > ", color.HIGH_BLUE)
		c := sio("Enter a Password   > ", color.HIGH_PINK)
		SQL.Ping_DB_2(a, b, c, "", "MySQL")
	case "db auth postgres":
		b := sio("Enter a Username   > ", color.HIGH_BLUE)
		c := sio("Enter a Password   > ", color.HIGH_PINK)
		d := sio("Enter the db name  > ", color.HIGH_BLUE)
		SQL.Ping_DB_2("", b, c, d, "PostGreSQl")
	// start http server
	case "start http server":
		bin := Detect_ARCH()
		fmt.Print("\n\nHTTP server will be started by defualt on port 5509\n\n")
		fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| google link  -> http://localhost:5509")
		fmt.Println("\033[38;5;55m|\033[38;5;43m+\033[38;5;55m| Firefox link -> localhost:5509")
		server.Run_Server(bin)
	// shells (Experimental)
	case "start ssh tunel":
		local_hostname := sio("Enter the localhost hostname> ", v.RET_RED)
		local_portname := iio("Enter the localhost port to listen on> ", v.RET_RED)
		server_hostname := sio("Enter the remote server hostname> ", v.BLU)
		server_port := iio("Enter the remote server port> ", v.BLU)
		remote_hostname := sio("Enter the remote hostname> ", v.WHT)
		remote_portname := iio("Enter the remote portname> ", v.WHT)
		ssh_user := sio("Enter the SSH username> ", v.RED)
		services.Parse_Args_conf(
			local_hostname,
			server_hostname,
			remote_hostname,
			ssh_user,
			local_portname,
			server_port,
			remote_portname)
	case "start listen bind": // start a bind shell listener
		addr := sio("Enter a address : ", v.RET_RED)
		port := sio("Enter a port    : ", v.RET_RED)
		web3point0utils.Load_Bind_shell_NOREVERSE(addr, port)
	case "start listen tcp":
		addr := sio("Enter a address : ", v.RET_RED)
		port := sio("Enter a port    : ", v.RET_RED)
		web3point0utils.Load_Reverse_TCP_Shell(addr, port)
	case "start listen http":
		addr := sio("Enter a address : ", v.RET_RED)
		port := sio("Enter a port    : ", v.RET_RED)
		web3point0utils.Load_HTTP_Shell(addr, port)
	case "start def interface":
		a := interface_cpp_utils.Defualt_interface()
		namec := sio("Enter the new interface name> ", v.RET_RED)
		interface_cpp_utils.Run_CPP("up", a, namec, "modules/go-main/80211/interface", "no")
	case "start cus interface":
		a := sio("Enter the interface name> ", v.RET_RED)
		namec := sio("Enter the new interface name> ", v.RET_RED)
		interface_cpp_utils.Run_CPP("up", a, namec, "modules/go-main/80211/interface", "no")
	case "stop def interface":
		a := sio("Enter the changed name of the interface> ", v.RET_RED)
		b := sio("Enter the name you want the interface to be named> ", v.RET_RED)
		interface_cpp_utils.Run_CPP("down", a, b, "modules/go-main/80211/interface", "no")
	// api modules
	case "api whoisx":
		a := sio("Enter a username for the API> ", v.RET_RED)
		b := sio("Enter a password for the API> ", v.RET_RED)
		c := sio("Enter a website to lookup   > ", v.RET_RED)
		GENERAL_API_UTILS.Make_Request_WHOIS_XML_API_FREE_SERVICE(c, a, b)
	case "api whoisx config":
		_, _, whois_user, whois_pass := GENERAL_API_UTILS_SECTOR_28.Ret_api("")
		web := sio("Enter a website to lookup  > ", v.RET_RED)
		GENERAL_API_UTILS.Make_Request_WHOIS_XML_API_FREE_SERVICE(web, whois_user, whois_pass)
	case "api layerus":
		fmt.Println("\n[!] Example: Format must be as follows +xxxxxxxxxxx EX -> +19644520897 ")
		a := sio("\nEnter a number      > ", v.RET_RED)
		b := sio("\nEnter a API Key     > ", v.RET_RED)
		fmt.Println("[!] Example: format must be xxx example is as follows -> 334")
		c := sio("\nEnter the dial code > ", v.RET_RED)
		GENERAL_API_UTILS.Make_Request_API_LAYER_PHONE_INFO(a, b, true, false, c)
	case "api layerus config":
		fmt.Println("\n[!] Example: Format must be as follows +xxxxxxxxxxx EX -> +19644520897 ")
		a := sio("\nEnter a number      > ", v.RET_RED)
		fmt.Println("[!] Example: format must be xxx example is as follows -> 334")
		c := sio("\nEnter the dial code > ", v.RET_RED)
		api_layer_APIKEY, _, _, _ := GENERAL_API_UTILS_SECTOR_28.Ret_api("")
		GENERAL_API_UTILS.Make_Request_API_LAYER_PHONE_INFO(a, api_layer_APIKEY, true, false, c)
	case "api layerbe":
		SSB(flags_rr6.Screen_rotation)
		fmt.Println("\n[!] Example: Format must be as follows +xxxxxxxxxxx EX -> +19644520897 ")
		a := sio("\nEnter a number      > ", v.RET_RED)
		b := sio("\nEnter a API Key     > ", v.RET_RED)
		fmt.Println("[!] Example: format must be xxx example is  as follows -> +971-5#-###-#### given this is a belgium number")
		c := sio("\nEnter the dial code > ", v.RET_RED)
		GENERAL_API_UTILS.Make_Request_API_LAYER_PHONE_INFO(a, b, false, true, c)
	case "api layerbe config":
		fmt.Println("\n[!] Example: Format must be as follows +xxxxxxxxxxx EX -> +19644520897 ")
		a := sio("\nEnter a number      > ", v.RET_RED)
		fmt.Println("[!] Example: format must be xxx example is as follows -> 334")
		c := sio("\nEnter the dial code > ", v.RET_RED)
		api_layer_APIKEY, _, _, _ := GENERAL_API_UTILS_SECTOR_28.Ret_api("")
		GENERAL_API_UTILS.Make_Request_API_LAYER_PHONE_INFO(a, api_layer_APIKEY, false, true, c)
	case "api grab config":
		kapilayer_key, whois_apikey, whois_user, whois_pass := GENERAL_API_UTILS_SECTOR_28.Ret_api("")
		fmt.Println("|+| Value - APILAYER API Key  -> ", kapilayer_key)
		fmt.Println("|+| Value - WHOISXML API Key  -> ", whois_apikey)
		fmt.Println("|+| Value - WHOISXML username -> ", whois_user)
		fmt.Println("|+| Value - WHOISXML password -> ", whois_pass)
	// attack modules
	case "atk fuzz": // run fuzzer
		a := sio("Enter the IP of the service     -> ", v.WHT)
		b := sio("Enter the port of the service   -> ", v.WHT)
		c := sio("Enter the size in bytes to fuzz -> ", v.WHT)
		fmt.Println("\033[31m|\033[90m+\033[31m| Value <Port> -> ", b)
		fmt.Println("\033[31m|\033[90m+\033[31m| Value <Addr> -> ", a)
		fmt.Println("\033[31m|\033[90m+\033[31m| Value <Fuzz> -> ", c)
		f, _ := strconv.Atoi(b)
		fuzz.Main(b, a, f)
	case "atk permission":
		a := sio("Enter the filename to change -> ", v.WHT)
		b := sio("Enter the premission number  -> ", v.WHT)
		STOMPER.Permissions(b, a)
	case "atk timestamp":
		a := sio("Enter the filename to modify   -> ", v.WHT)
		hou := sio("Enter the hours to add      -> ", v.RED)
		sec := sio("Enter the seconds to add    -> ", v.BLU)
		h, _ := time.ParseDuration(hou)
		s, _ := time.ParseDuration(sec)
		STOMPER.Change_Timestamp(a, h, s)
	case "atk dnsspoof":
		if flags_rr6.Gateway_mac == "" || flags_rr6.Sniffc == "" || flags_rr6.Target_mac == "" || flags_rr6.Target_spoof == "" {
			fmt.Println("|-| Warning: Flags of the following list might not have been defined [ --gatemac, --targetip, --interface, --targetm ]")
			fmt.Println("|-| Warning: For more information type --help when running the script, the interface tag specifies a interface")
			fmt.Println("|-| Warning: the gatemac specifies the gateway mac, the --targetip specifies the gateway IP, the --targetm specifies")
			fmt.Println("|-| Warning: the targets mac to mangle the DNS to")
			fmt.Println("|-| Warning: Prompting user based input.....")
			fmt.Println(":::......................................................................................................................")
			Gateway_mac := sio("Enter the gateway mac  eg (FF:FF:FF:FF:FF:FF)    -> ", v.HIGH_BLUE)
			Gateway_IPA := sio("Enter the gateway IPA  eg (10.0.0.1)             -> ", v.HIGH_PINK)
			Interface := sio("Enter the interface    eg (wlanmon0)             -> ", v.HIGH_BLUE)
			Target_mac := sio("Enter the target MAC   eg (ff:ff:ff:ff:ff:ff)    -> ", v.HIGH_PINK)
			BPF := sio("Enter the BPF to set   eg (dst port 53)          -> ", v.HIGH_BLUE)
			Mangle_DNS.Run(Interface, BPF, Target_mac, Gateway_IPA, Gateway_mac)
		} else {
			BPF := sio("Enter the BPF to set   eg (dst port 53)          -> ", v.HIGH_BLUE)
			Mangle_DNS.Run(flags_rr6.Sniffc, BPF, flags_rr6.Target_mac, flags_rr6.Target_spoof, flags_rr6.Gateway_mac)
		}
	//*********************************************************************************************************
	//*          This break concludes the attack modules and moved onto the engines module                    *
	//*                                                                                                       *
	//*********************************************************************************************************
	case "engine otwitter":
		if flags_rr6.Search_Query == "" {
			Query := sio("Enter a search query > ", v.HIGH_BLUE)
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, Query, "twitter")
		} else {
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, flags_rr6.Search_Query, "twitter")
		}
	case "engine ofacebook":
		if flags_rr6.Search_Query == "" {
			Query := sio("Enter a search query > ", v.HIGH_BLUE)
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, Query, "facebook")
		} else {
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, flags_rr6.Search_Query, "facebook")
		}
	case "engine olinkedin":
		if flags_rr6.Search_Query == "" {
			Query := sio("Enter a search query > ", v.HIGH_BLUE)
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, Query, "linkedin")
		} else {
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, flags_rr6.Search_Query, "linkedin")
		}
	case "engine ogoogle":
		if flags_rr6.Search_Query == "" {
			Query := sio("Enter a search query > ", v.HIGH_BLUE)
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, Query, "google")
		} else {
			Engine_OSINT.Caller(flags_rr6.Results_per_Page, flags_rr6.Pages_To_Crawl, flags_rr6.Search_Query, "google")
		}
	case "engine cve":
		cve := sio("Enter a CVE Name or possible date> ", v.RET_RED)
		Engine_CVE.Check_CVE(cve, false)
	case "engine tcve":
		cve := sio("Enter a CVE Name or possible date> ", v.RET_RED)
		Engine_CVE.Check_CVE(cve, true)
	case "engine shodanh":
		host := sio("Enter a Hostname -> ", v.RET_RED)
		skey := sio("Enter shodan API key -> ", v.RET_RED)
		data, _ := Engine_Shodan.Host(host, skey)
		fmt.Println(data)

	default:
		fmt.Println("command does not exist")
	}
}

func Detect_ARCH() string {
	x := runtime.GOARCH
	switch x {
	case "arm64":
		server_binary = "modules/web/bin/ARM64/server_arm64"
	case "arm32":
		server_binary = "modules/web/bin/ARM32/server_arm32"
	case "amd64":
		server_binary = "modules/web/bin/AMD64/server_amd64"
	}
	if server_binary != "" {
		return server_binary
	} else {
		return "ERROR: No placement has been filled here, server binary must not be supported, SUPPORTED SYSTEMS AND ARCHITECTURES ARE | arm32, arm64, amd64 and supported operating systems are [ linux ]"
	}
}
